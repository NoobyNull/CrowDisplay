---
phase: 06-data-driven-display-ui
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - display/ui.cpp
  - display/main.cpp
  - display/config_server.cpp
autonomous: true

must_haves:
  truths:
    - "Config reload rebuilds display UI without device reboot"
    - "Repeated config reloads do not exhaust LVGL memory (verified by lv_mem_monitor delta)"
    - "Editing JSON on SD card and triggering reload renders updated layout"
  artifacts:
    - path: "display/ui.cpp"
      provides: "Full-screen rebuild via lv_obj_clean with memory monitoring"
      contains: "lv_obj_clean"
    - path: "display/ui.cpp"
      provides: "lv_mem_monitor logging after each rebuild"
      contains: "lv_mem_monitor"
    - path: "display/config_server.cpp"
      provides: "Safe config reload into global AppConfig"
      contains: "g_app_config"
    - path: "display/main.cpp"
      provides: "Deferred rebuild flag checked in loop()"
      contains: "rebuild_pending"
  key_links:
    - from: "display/config_server.cpp handle_config_upload"
      to: "display/main.cpp rebuild flag"
      via: "Sets global flag, loop() calls rebuild_ui after lv_obj_clean"
      pattern: "rebuild_pending.*true"
    - from: "display/ui.cpp rebuild_ui"
      to: "display/ui.cpp create_ui widgets"
      via: "lv_obj_clean(main_screen) then re-create all widgets from config"
      pattern: "lv_obj_clean.*main_screen"
---

<objective>
Implement safe hot-reload with full-screen rebuild, deferred rebuild flag, and LVGL memory monitoring to prove no memory leaks on repeated config reloads.

Purpose: DRVUI-04 (hot-reload without reboot) and DRVUI-05 (widget-pool / no memory leaks) require a robust rebuild mechanism. The current rebuild_ui() only replaces the tabview, leaving headers in inconsistent state. This plan implements full lv_obj_clean() rebuild with all widget pointer nulling, deferred rebuild from loop() context to avoid animation conflicts, and lv_mem_monitor() before/after logging.

Output: A hot-reload system where config_server sets a flag, loop() executes the rebuild safely, and serial output proves memory stability across reloads.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-driven-display-ui/06-RESEARCH.md
@.planning/phases/06-data-driven-display-ui/06-01-SUMMARY.md
@display/ui.cpp
@display/ui.h
@display/main.cpp
@display/config.h
@display/config_server.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement full-screen rebuild with memory monitoring</name>
  <files>display/ui.cpp</files>
  <action>
**Note:** This task combines four transformations (extract helper, rewrite rebuild_ui, update create_ui, add memory monitoring) because they are tightly coupled -- all are part of the same rebuild mechanism and the helper extraction must happen atomically with the callers being updated to use it.

Rewrite `rebuild_ui()` in ui.cpp to use full-screen `lv_obj_clean()` instead of deleting only the tabview.

**Step 1: Extract widget creation into a helper function.**

Create a static helper `create_ui_widgets(lv_obj_t *screen, const AppConfig *cfg)` that contains the widget creation logic currently inside `create_ui()` -- everything AFTER `main_screen = lv_scr_act()` and background style, EXCEPT for clock_screen and ota_screen creation (those are created once and persist). Specifically, this helper creates:
- Header bar (45px) with title, status_label, rssi_label, OTA button, brightness button
- Stats header (via create_stats_header)
- Tabview with pages and buttons from config

This helper is called by both `create_ui()` and `rebuild_ui()`.

**Step 2: Rewrite rebuild_ui().**

```cpp
void rebuild_ui(const AppConfig* cfg) {
    if (!cfg || !main_screen) {
        Serial.println("rebuild_ui: invalid args");
        return;
    }

    // Memory before rebuild
    lv_mem_monitor_t mon_pre;
    lv_mem_monitor(&mon_pre);

    // Step 1: Destroy ALL children of main screen
    lv_obj_clean(main_screen);

    // Step 2: Null all widget pointers (now dangling after clean)
    tabview = nullptr;
    status_label = nullptr;
    stats_header = nullptr;
    stats_visible = false;
    rssi_label = nullptr;
    bright_btn = nullptr;
    memset(stat_labels, 0, sizeof(stat_labels));

    // Step 3: Update active config pointer
    g_active_config = cfg;

    // Step 4: Recreate all widgets on main screen
    create_ui_widgets(main_screen, cfg);

    // Step 5: Memory after rebuild
    lv_mem_monitor_t mon_post;
    lv_mem_monitor(&mon_post);

    uint32_t used_pre = mon_pre.total_size - mon_pre.free_size;
    uint32_t used_post = mon_post.total_size - mon_post.free_size;
    Serial.printf("UI rebuild: LVGL mem used=%u->%u (delta=%d), free=%u, frag=%u, biggest=%u\n",
                  used_pre, used_post, (int32_t)(used_post - used_pre),
                  mon_post.free_size, mon_post.free_cnt, mon_post.free_biggest_size);
}
```

**Step 3: Update create_ui()** to call the shared helper:
```cpp
void create_ui(const AppConfig* cfg) {
    if (!cfg) { Serial.println("create_ui: nullptr"); return; }
    g_active_config = cfg;
    main_screen = lv_scr_act();
    lv_obj_set_style_bg_color(main_screen, lv_color_hex(0x0f0f23), LV_PART_MAIN);

    // Create clock screen and OTA screen (once, persist across rebuilds)
    // ... (existing clock_screen and ota_screen creation code) ...

    // Create main screen widgets
    create_ui_widgets(main_screen, cfg);

    Serial.println("UI initialized");
}
```

**IMPORTANT:** The `create_ui_widgets()` helper must create widgets on the passed `screen` parameter, NOT on `lv_scr_act()`. Replace any `lv_scr_act()` references inside the helper with the `screen` parameter. For example: `lv_obj_t *header = lv_obj_create(screen);` not `lv_obj_create(lv_scr_act())`.

**IMPORTANT:** Do NOT recreate clock_screen or ota_screen in rebuild_ui or the helper -- those are separate LVGL screens created once in create_ui() and reused.
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && pio run -e display` and confirm clean compilation. Verify `grep -n "lv_obj_clean\|lv_mem_monitor" display/ui.cpp` shows both functions present. Verify `grep -n "create_ui_widgets(main_screen" display/ui.cpp` shows both create_ui() and rebuild_ui() calling the shared helper with the screen parameter.
  </verify>
  <done>
rebuild_ui() uses lv_obj_clean(main_screen) for full rebuild. All widget pointers nulled after clean. lv_mem_monitor() logs memory before and after each rebuild. create_ui_widgets() shared between create_ui() and rebuild_ui(). Clock and OTA screens are NOT affected by rebuild.
  </done>
</task>

<task type="auto">
  <name>Task 2: Deferred rebuild flag and safe config reload in config_server</name>
  <files>display/main.cpp, display/config_server.cpp</files>
  <action>
**Problem:** config_server's handle_config_upload() currently calls rebuild_ui() directly from within the WebServer handler. This runs in the context of web_server->handleClient() called from loop(). While this is technically in the loop() context already (not an LVGL callback), an LVGL animation (e.g., tab switch) could be in progress. Using a deferred rebuild flag is safer and follows the research recommendation.

**In display/main.cpp:**
- Add a file-scope flag: `static volatile bool g_rebuild_pending = false;`
- Add a public function to set it:
  ```cpp
  void request_ui_rebuild() {
      g_rebuild_pending = true;
  }
  ```
- Declare in a header (ui.h or a new small header -- prefer adding to ui.h since it's UI-related):
  ```cpp
  void request_ui_rebuild();
  ```
- Also add a public accessor for the global config, so config_server can update it:
  ```cpp
  AppConfig& get_global_config();
  ```
  Implementation in main.cpp:
  ```cpp
  AppConfig& get_global_config() { return g_app_config; }
  ```
  Declare in config.h or ui.h (prefer config.h since it's config-related).

- In loop(), add rebuild check AFTER lvgl_tick() and BEFORE power_update():
  ```cpp
  // Deferred UI rebuild (triggered by config upload)
  if (g_rebuild_pending) {
      g_rebuild_pending = false;
      rebuild_ui(&g_app_config);
  }
  ```

**In display/config_server.cpp:**
- Replace the current reload logic in handle_config_upload() (UPLOAD_FILE_END block). Instead of creating a local `AppConfig new_config` and calling `rebuild_ui(&new_config)`:
  ```cpp
  // Load new config into global
  AppConfig new_cfg = config_load();
  const ProfileConfig* profile = new_cfg.get_active_profile();
  if (!profile || profile->pages.empty()) {
      Serial.println("Config: uploaded config invalid, keeping current");
      free(config_buffer);
      config_buffer = nullptr;
      return;
  }

  // Update global config (all LVGL widgets destroyed before this in rebuild)
  get_global_config() = new_cfg;
  Serial.printf("Config: loaded updated config, profile: %s, %zu pages\n",
                new_cfg.active_profile_name.c_str(), profile->pages.size());

  // Request deferred rebuild (will execute from loop context)
  request_ui_rebuild();
  Serial.println("Config: rebuild requested");
  ```

**In display/ui.h:**
- Add declaration: `void request_ui_rebuild();`
- Add declaration: `AppConfig& get_global_config();`
  (Or put get_global_config in config.h if preferred. The key is config_server.cpp can call both.)

**IMPORTANT sequence in rebuild_ui():** The rebuild_ui function must:
1. lv_obj_clean(main_screen) -- destroys all widgets, invalidates all ButtonConfig* pointers
2. Then create_ui_widgets reads from g_active_config (which was already updated before the flag was set... wait, actually the flag is set AFTER updating g_app_config, and rebuild reads from the pointer already stored). Let me reconsider the sequence:

Actually the sequence is:
1. config_server sets `get_global_config() = new_cfg` (copies new data into g_app_config)
2. config_server sets rebuild flag
3. loop() sees flag, calls `rebuild_ui(&g_app_config)`
4. rebuild_ui calls lv_obj_clean (destroys widgets, their user_data pointers are freed with them)
5. rebuild_ui calls create_ui_widgets (creates new widgets pointing into updated g_app_config)

This is safe because step 1 replaces the config data while step 4 hasn't happened yet -- but no LVGL widgets are being event-processed between steps 1 and 4 because we're in the same loop() iteration (single-threaded). The old widgets still exist but won't be clicked during this code path. This is correct.
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && pio run -e display` and confirm clean compilation. Verify `grep -n "rebuild_pending\|request_ui_rebuild\|get_global_config" display/main.cpp display/config_server.cpp display/ui.h` shows the deferred rebuild pattern wired correctly.
  </verify>
  <done>
Config upload sets deferred rebuild flag instead of calling rebuild_ui directly. loop() checks flag and calls rebuild_ui from safe context. Global config is updated before rebuild flag is set. config_server no longer creates local AppConfig for rebuild. Serial logs confirm config load and rebuild request.
  </done>
</task>

</tasks>

<verification>
1. `pio run -e display` compiles cleanly with zero errors
2. `grep -n "lv_obj_clean" display/ui.cpp` shows full-screen clean in rebuild_ui
3. `grep -n "lv_mem_monitor" display/ui.cpp` shows memory logging
4. `grep -n "rebuild_pending" display/main.cpp` shows deferred flag pattern
5. `grep -rn "AppConfig new_config" display/config_server.cpp` returns NO matches (no local config for rebuild)
6. No `Hotkey` struct references remain anywhere in the display source
</verification>

<success_criteria>
- rebuild_ui() uses lv_obj_clean(main_screen) for complete widget teardown
- All static widget pointers nulled after clean, then reassigned during rebuild
- lv_mem_monitor() logs before/after memory on every rebuild (proves DRVUI-05)
- Config server uses deferred flag pattern, not direct rebuild_ui call
- Global config updated atomically before rebuild flag is set
- Firmware compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-driven-display-ui/06-02-SUMMARY.md`
</output>
