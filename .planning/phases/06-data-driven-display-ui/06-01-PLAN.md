---
phase: 06-data-driven-display-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - display/main.cpp
  - display/ui.cpp
  - display/ui.h
autonomous: true

must_haves:
  truths:
    - "Display renders pages and buttons from AppConfig struct, not hardcoded arrays"
    - "Variable page count and variable buttons per page rendered from config"
    - "Each button shows its configured label, color, icon symbol, and keystroke description"
    - "Button press fires the correct keystroke or media key from ButtonConfig data"
  artifacts:
    - path: "display/main.cpp"
      provides: "Static AppConfig with program lifetime"
      contains: "static AppConfig g_app_config"
    - path: "display/ui.cpp"
      provides: "Single config-driven render path with ButtonConfig* as event user_data"
      contains: "const ButtonConfig *btn"
  key_links:
    - from: "display/ui.cpp btn_event_cb"
      to: "ButtonConfig in g_app_config"
      via: "lv_event_get_user_data returns ButtonConfig* pointing into global config"
      pattern: "ButtonConfig.*lv_event_get_user_data"
    - from: "display/main.cpp setup()"
      to: "display/ui.cpp create_ui()"
      via: "Passes pointer to static g_app_config"
      pattern: "create_ui.*g_app_config"
---

<objective>
Fix critical dangling-pointer bugs and eliminate the dual rendering path so the display UI is driven entirely from the AppConfig struct.

Purpose: The current code has three use-after-free bugs (stack-local Hotkey as event user_data, local AppConfig in setup(), local AppConfig in config_server rebuild) and a redundant hardcoded fallback path. This plan fixes all pointer lifetime issues and removes the dual rendering path, making config_create_defaults() the sole source of default data.

Output: A display firmware where every button press safely reads from a long-lived AppConfig, and the UI is always rendered from the config struct.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-data-driven-display-ui/06-RESEARCH.md
@.planning/phases/05-config-data-model-sd-loading/05-01-SUMMARY.md
@display/ui.cpp
@display/ui.h
@display/main.cpp
@display/config.h
@display/config_server.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix config lifetime and eliminate Hotkey struct</name>
  <files>display/main.cpp, display/ui.cpp, display/ui.h</files>
  <action>
**In display/main.cpp:**
- Change `AppConfig app_config = config_load();` inside setup() to a file-scope static: `static AppConfig g_app_config;` declared before setup().
- In setup(), assign: `g_app_config = config_load();`
- Pass `&g_app_config` to create_ui().
- Add a public getter function or extern declaration so config_server.cpp can access g_app_config for reload (see Task 2 of plan 06-02).

**In display/ui.cpp:**
- Remove the `Hotkey` struct entirely (lines 46-55).
- Remove the `button_config_to_hotkey()` function (lines 59-70).
- Remove the `HotkeyPage` struct (lines 72-76).
- Remove ALL hardcoded page arrays: `page1_hotkeys[]`, `page2_hotkeys[]`, `page3_hotkeys[]`, the `pages[]` array, and `NUM_PAGES` (lines 81-142).
- Remove the hardcoded fallback branch in create_ui() (the `if (!g_active_config)` block that iterates `pages[]`).
- Remove the `create_hotkey_page()` function that takes `HotkeyPage&` (lines 266-278) -- it references the deleted structs.

- Rewrite `btn_event_cb()` to cast user_data to `const ButtonConfig*` instead of `const Hotkey*`:
  ```cpp
  static void btn_event_cb(lv_event_t *e) {
      lv_event_code_t code = lv_event_get_code(e);
      if (code == LV_EVENT_CLICKED) {
          const ButtonConfig *btn = (const ButtonConfig *)lv_event_get_user_data(e);
          if (!btn) return;
          if (btn->action_type == ACTION_MEDIA_KEY) {
              send_media_key_to_bridge(btn->consumer_code);
          } else {
              send_hotkey_to_bridge(btn->modifiers, btn->keycode);
          }
          if (status_label) {
              lv_label_set_text_fmt(status_label, LV_SYMBOL_OK " Sent: %s (%s)",
                                    btn->label.c_str(), btn->description.c_str());
          }
          Serial.printf("Hotkey: %s (%s) mod=0x%02X key=0x%02X media=%d\n",
                        btn->label.c_str(), btn->description.c_str(),
                        btn->modifiers, btn->keycode, btn->action_type == ACTION_MEDIA_KEY);
      }
  }
  ```
  Note: btn->label.c_str() and btn->description.c_str() are safe because lv_label_set_text_fmt copies the string.

- Rewrite `create_hotkey_button()` to accept `const ButtonConfig*` instead of `const Hotkey*`:
  ```cpp
  static lv_obj_t *create_hotkey_button(lv_obj_t *parent, const ButtonConfig *btn) {
  ```
  Use `btn->color`, `btn->icon.c_str()`, `btn->label.c_str()`, `btn->description.c_str()`.
  Check icon with `!btn->icon.empty()` instead of `hk->icon`.
  Pass `(void *)btn` as event user_data -- this pointer points into the long-lived global AppConfig.

- In `create_ui()`: remove the `if (cfg)` / `else` branch. Always require cfg. At the top:
  ```cpp
  void create_ui(const AppConfig* cfg) {
      if (!cfg) {
          Serial.println("create_ui: nullptr config, cannot create UI");
          return;
      }
      g_active_config = cfg;
  ```
  Then the config-driven page creation loop passes `&page.buttons[j]` (pointer into the config) to create_hotkey_button:
  ```cpp
  for (size_t j = 0; j < page.buttons.size(); j++) {
      create_hotkey_button(tab, &page.buttons[j]);
  }
  ```
  Remove the fallback "no config" block entirely.

- In `create_ui()` signature in ui.h: remove the `= nullptr` default parameter. Make it `void create_ui(const AppConfig* cfg);`

- Remove the color palette #defines (CLR_RED, CLR_BLUE, etc.) ONLY if they are not used elsewhere in the file (they are still used in stats_header, device_status, clock_screen, OTA screen -- so KEEP them). Remove ONLY the key code defines (KEY_RETURN, KEY_LEFT_ARROW, etc.) since button keycodes now come from config.

Since we are removing the Hotkey struct and button_config_to_hotkey(), rebuild_ui() will fail to compile. So we MUST also update rebuild_ui() in this task to use ButtonConfig* instead of Hotkey. Update the rebuild_ui() page creation loop to match the create_ui() pattern:
  ```cpp
  for (size_t j = 0; j < page.buttons.size(); j++) {
      create_hotkey_button(tab, &page.buttons[j]);
  }
  ```
  This fixes the dangling pointer bug in rebuild_ui() as well (since &page.buttons[j] points into the global config, not a stack local).
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && pio run -e display` and confirm clean compilation with zero errors and zero warnings related to Hotkey, HotkeyPage, or button_config_to_hotkey. Verify that the Hotkey struct, button_config_to_hotkey function, HotkeyPage struct, and all hardcoded page arrays are completely absent from ui.cpp (grep for them).
  </verify>
  <done>
display firmware compiles cleanly. No Hotkey struct, no HotkeyPage struct, no button_config_to_hotkey(), no hardcoded page arrays in ui.cpp. AppConfig is static with program lifetime in main.cpp. btn_event_cb uses ButtonConfig*. create_hotkey_button accepts ButtonConfig*. create_ui() and rebuild_ui() both pass &page.buttons[j] as event user_data.
  </done>
</task>

</tasks>

<verification>
1. `pio run -e display` compiles cleanly
2. `grep -n "Hotkey\|HotkeyPage\|button_config_to_hotkey\|page1_hotkeys\|page2_hotkeys\|page3_hotkeys" display/ui.cpp` returns no matches (except possibly "hotkey" in comments or log strings, which is fine)
3. `grep -n "static AppConfig" display/main.cpp` confirms global config
4. `grep -n "ButtonConfig.*lv_event_get_user_data" display/ui.cpp` confirms safe event handler
</verification>

<success_criteria>
- Display firmware compiles with zero errors
- All Hotkey/HotkeyPage structs and hardcoded page arrays removed from ui.cpp
- AppConfig has program lifetime (static in main.cpp file scope)
- Button event callbacks use ButtonConfig* pointing into the long-lived config
- Single config-driven rendering path (no hardcoded fallback in create_ui)
</success_criteria>

<output>
After completion, create `.planning/phases/06-data-driven-display-ui/06-01-SUMMARY.md`
</output>
