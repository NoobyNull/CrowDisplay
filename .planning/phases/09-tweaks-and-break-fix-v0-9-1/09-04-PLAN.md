---
phase: 9
plan: 4
title: "Display Modes: Picture Frame + Clock + Standby"
depends_on: []
---

# Plan 09-04: Display Modes Integration

## Goal
Add four display modes (hotkeys, clock, picture frame, standby) with mode switching, analog/digital clock rendering, and SD card image slideshow with PSRAM-optimized JPEG decoding.

## Context
Current implementation has 3 power states (ACTIVE/DIMMED/CLOCK) that conflate brightness control with UI mode. This plan separates concerns: `DisplayMode` controls what to show (hotkeys vs clock vs pictures), `PowerState` controls brightness. Adds picture frame mode with LVGL SJPG decoder for memory-efficient image loading from SD card.

**Files affected:**
- `display/power.h` - Add DisplayMode enum, mode switching API
- `display/power.cpp` - Mode state management
- `display/ui.cpp` - Picture frame screen, analog clock rendering, mode transitions
- `display/config.h` - Add display mode config (default mode, slideshow interval, clock style)
- `companion/ui/editor_main.py` - Display mode configuration panel

## Tasks

<task id="1">
<title>Define DisplayMode enum and mode switching architecture</title>
<files>display/power.h, display/power.cpp</files>
<action>
1. In `display/power.h`, add `DisplayMode` enum:
   ```cpp
   enum DisplayMode : uint8_t {
       MODE_HOTKEYS,       // Main hotkey UI (default)
       MODE_CLOCK,         // Clock display (analog or digital)
       MODE_PICTURE_FRAME, // Image slideshow from SD card
       MODE_STANDBY,     // Minimal standby UI (stats + clock only)
   };
   ```

2. Add mode switching functions to public API:
   ```cpp
   void display_set_mode(DisplayMode mode);   // Switch to new mode
   DisplayMode display_get_mode();            // Get current mode
   ```

3. In `display/power.cpp`, add mode state management:
   ```cpp
   static DisplayMode current_mode = MODE_HOTKEYS;

   void display_set_mode(DisplayMode mode) {
       if (mode == current_mode) return;

       DisplayMode prev_mode = current_mode;
       current_mode = mode;

       // Call UI transition handler (implemented in ui.cpp)
       extern void ui_transition_mode(DisplayMode from, DisplayMode to);
       ui_transition_mode(prev_mode, mode);

       Serial.printf("Display mode: %d -> %d\n", prev_mode, mode);
   }

   DisplayMode display_get_mode() {
       return current_mode;
   }
   ```

4. Document mode vs power state orthogonality:
   - MODE_HOTKEYS + POWER_ACTIVE = Full brightness hotkey UI
   - MODE_HOTKEYS + POWER_DIMMED = Dimmed hotkey UI (idle timeout)
   - MODE_CLOCK + POWER_CLOCK = Low brightness clock (PC off)
   - MODE_PICTURE_FRAME + POWER_ACTIVE = Full brightness slideshow
   - etc.

5. Add mode switching triggers:
   - Long-press brightness button: cycle modes (HOTKEYS -> CLOCK -> PICTURE_FRAME -> MACRO_PAD -> HOTKEYS)
   - MSG_POWER_STATE shutdown: switch to MODE_CLOCK (existing behavior)
   - Touch activity in MODE_CLOCK: switch back to MODE_HOTKEYS (existing behavior)
</action>
<verify>
1. Build firmware: `pio run -e running`
2. Check power.h compiles without errors
3. Verify DisplayMode enum values are sequential (0-3)
4. Test mode switching via Serial command: "mode 1" -> switches to MODE_CLOCK
5. Verify mode persists across power state changes
</verify>
<done>power.h defines DisplayMode enum and mode switching API. power.cpp manages current_mode state. Mode is orthogonal to PowerState (separate concerns).</done>
</task>

<task id="2">
<title>Implement picture frame mode with SD card image slideshow</title>
<files>display/ui.cpp, display/config.h, platformio.ini</files>
<action>
1. In `platformio.ini`, enable LVGL image decoders in build flags:
   ```ini
   build_flags =
       -D LV_USE_SJPG=1          # Split JPEG decoder (memory efficient)
       -D LV_USE_BMP=1           # BMP support
       # ... existing flags
   ```

2. In `display/config.h`, add picture frame config:
   ```cpp
   struct AppConfig {
       // ... existing fields
       DisplayMode default_mode;              // MODE_HOTKEYS, etc.
       uint16_t slideshow_interval_sec;       // Picture frame mode interval (default 30)
       bool clock_analog;                      // true = analog, false = digital
   };
   ```

3. In `display/ui.cpp`, add picture frame screen and state:
   ```cpp
   // Picture frame mode state
   static lv_obj_t *picture_frame_screen = nullptr;
   static lv_obj_t *slideshow_img = nullptr;
   static std::vector<String> slideshow_files;
   static size_t slideshow_index = 0;
   static lv_timer_t *slideshow_timer = nullptr;

   void init_picture_frame_mode() {
       if (!picture_frame_screen) {
           picture_frame_screen = lv_obj_create(NULL);
           lv_obj_set_style_bg_color(picture_frame_screen, lv_color_black(), LV_PART_MAIN);
           lv_obj_set_style_bg_opa(picture_frame_screen, LV_OPA_COVER, LV_PART_MAIN);
       }

       // Scan SD card /pictures directory for images
       slideshow_files.clear();
       File dir = SD.open("/pictures");
       if (dir) {
           while (File entry = dir.openNextFile()) {
               if (!entry.isDirectory()) {
                   String name = entry.name();
                   if (name.endsWith(".jpg") || name.endsWith(".bmp")) {
                       slideshow_files.push_back("/pictures/" + name);
                   }
               }
               entry.close();
           }
           dir.close();
       }

       if (slideshow_files.empty()) {
           Serial.println("WARN: No images found in /pictures");
           // Create fallback message
           lv_obj_t *lbl = lv_label_create(picture_frame_screen);
           lv_label_set_text(lbl, "No images in /pictures\n\nUpload JPG/BMP files to SD card");
           lv_obj_center(lbl);
           lv_obj_set_style_text_color(lbl, lv_color_white(), LV_PART_MAIN);
           return;
       }

       // Create image widget (full screen)
       slideshow_img = lv_img_create(picture_frame_screen);
       lv_obj_set_size(slideshow_img, SCREEN_WIDTH, SCREEN_HEIGHT);
       lv_obj_align(slideshow_img, LV_ALIGN_CENTER, 0, 0);
       lv_img_set_zoom(slideshow_img, 256);  // 1:1 scale

       // Load first image
       slideshow_index = 0;
       load_next_slideshow_image();

       // Start timer for slideshow interval
       uint32_t interval_ms = g_active_config ? g_active_config->slideshow_interval_sec * 1000 : 30000;
       slideshow_timer = lv_timer_create(slideshow_timer_cb, interval_ms, nullptr);
   }

   void load_next_slideshow_image() {
       if (slideshow_files.empty() || !slideshow_img) return;

       // Build SD card path (S: = SD drive letter from lv_fs driver)
       String path = "S:" + slideshow_files[slideshow_index];

       Serial.printf("Loading image: %s\n", path.c_str());
       lv_img_set_src(slideshow_img, path.c_str());

       slideshow_index = (slideshow_index + 1) % slideshow_files.size();
   }

   void slideshow_timer_cb(lv_timer_t *timer) {
       load_next_slideshow_image();
   }

   void cleanup_picture_frame_mode() {
       if (slideshow_timer) {
           lv_timer_del(slideshow_timer);
           slideshow_timer = nullptr;
       }
       // Don't delete picture_frame_screen (reusable), just hide
   }
   ```

4. Register SD card filesystem driver with LVGL (if not already done):
   ```cpp
   // In display initialization (before create_ui)
   static void lvgl_register_sd_driver() {
       static lv_fs_drv_t drv;
       lv_fs_drv_init(&drv);
       drv.letter = 'S';  // Drive letter 'S' for SD card
       drv.open_cb = [](lv_fs_drv_t *drv, const char *path, lv_fs_mode_t mode) -> void* {
           File *file = new File();
           *file = SD.open(path + 2);  // Skip "S:" prefix
           return file->operator bool() ? file : nullptr;
       };
       drv.close_cb = [](lv_fs_drv_t *drv, void *file_p) -> lv_fs_res_t {
           File *file = (File*)file_p;
           file->close();
           delete file;
           return LV_FS_RES_OK;
       };
       drv.read_cb = [](lv_fs_drv_t *drv, void *file_p, void *buf, uint32_t btr, uint32_t *br) -> lv_fs_res_t {
           File *file = (File*)file_p;
           *br = file->read((uint8_t*)buf, btr);
           return LV_FS_RES_OK;
       };
       drv.seek_cb = [](lv_fs_drv_t *drv, void *file_p, uint32_t pos, lv_fs_whence_t whence) -> lv_fs_res_t {
           File *file = (File*)file_p;
           file->seek(pos);
           return LV_FS_RES_OK;
       };
       drv.tell_cb = [](lv_fs_drv_t *drv, void *file_p, uint32_t *pos_p) -> lv_fs_res_t {
           File *file = (File*)file_p;
           *pos_p = file->position();
           return LV_FS_RES_OK;
       };
       lv_fs_drv_register(&drv);
   }
   ```

5. Add memory monitoring for PSRAM fragmentation:
   ```cpp
   // Call periodically in slideshow mode
   lv_mem_monitor_t mon;
   lv_mem_monitor(&mon);
   if (mon.free_biggest_size < 768000) {  // 768 KB = 800x480 RGB565 image
       Serial.printf("WARN: PSRAM fragmentation detected, free_biggest=%u\n", mon.free_biggest_size);
       // TODO: Implement cache clearing or image size reduction
   }
   ```
</action>
<verify>
1. Create /pictures directory on SD card
2. Copy 3-5 JPG images (800x480 or smaller) to /pictures
3. Flash firmware, set mode to MODE_PICTURE_FRAME
4. Verify first image displays full-screen
5. Wait for slideshow interval (30 sec), verify image changes
6. Check serial for image loading: "Loading image: S:/pictures/image1.jpg"
7. Monitor LVGL memory: verify no leaks after 10+ image transitions
8. Test with missing /pictures directory: verify fallback message shown
</verify>
<done>Picture frame mode displays image slideshow from SD /pictures. LVGL SD filesystem driver registered. SJPG decoder enabled for memory efficiency. Slideshow timer cycles images at configured interval.</done>
</task>

<task id="3">
<title>Implement analog and digital clock rendering</title>
<files>display/ui.cpp</files>
<action>
1. Update existing `clock_screen` (created in `create_ui()`) to support analog mode:
   ```cpp
   // Add analog clock widgets (created once, hidden/shown as needed)
   static lv_obj_t *analog_clock_face = nullptr;
   static lv_obj_t *analog_hour_hand = nullptr;
   static lv_obj_t *analog_min_hand = nullptr;
   static lv_point_t hour_points[2];
   static lv_point_t min_points[2];

   void create_analog_clock_widgets(lv_obj_t *parent) {
       // Clock face (full circle arc)
       analog_clock_face = lv_arc_create(parent);
       lv_obj_set_size(analog_clock_face, 300, 300);
       lv_obj_center(analog_clock_face);
       lv_arc_set_bg_angles(analog_clock_face, 0, 360);
       lv_arc_set_value(analog_clock_face, 0);
       lv_obj_remove_style(analog_clock_face, NULL, LV_PART_KNOB);  // Remove knob
       lv_obj_set_style_arc_width(analog_clock_face, 4, LV_PART_MAIN);
       lv_obj_set_style_arc_color(analog_clock_face, lv_color_hex(0x888888), LV_PART_MAIN);

       // Hour hand
       analog_hour_hand = lv_line_create(parent);
       lv_line_set_points(analog_hour_hand, hour_points, 2);
       lv_obj_set_style_line_width(analog_hour_hand, 6, LV_PART_MAIN);
       lv_obj_set_style_line_color(analog_hour_hand, lv_color_white(), LV_PART_MAIN);
       lv_obj_set_style_line_rounded(analog_hour_hand, true, LV_PART_MAIN);

       // Minute hand
       analog_min_hand = lv_line_create(parent);
       lv_line_set_points(analog_min_hand, min_points, 2);
       lv_obj_set_style_line_width(analog_min_hand, 4, LV_PART_MAIN);
       lv_obj_set_style_line_color(analog_min_hand, lv_color_white(), LV_PART_MAIN);
       lv_obj_set_style_line_rounded(analog_min_hand, true, LV_PART_MAIN);

       // Initially hidden (shown when clock mode active)
       lv_obj_add_flag(analog_clock_face, LV_OBJ_FLAG_HIDDEN);
       lv_obj_add_flag(analog_hour_hand, LV_OBJ_FLAG_HIDDEN);
       lv_obj_add_flag(analog_min_hand, LV_OBJ_FLAG_HIDDEN);
   }
   ```

2. Update `update_clock_time()` to support both analog and digital:
   ```cpp
   void update_clock_time() {
       if (!clock_screen) return;

       time_t now = time(nullptr);
       struct tm *tm = localtime(&now);

       bool use_analog = g_active_config ? g_active_config->clock_analog : false;

       if (use_analog) {
           // Hide digital, show analog
           if (clock_time_label) lv_obj_add_flag(clock_time_label, LV_OBJ_FLAG_HIDDEN);
           if (analog_clock_face) lv_obj_clear_flag(analog_clock_face, LV_OBJ_FLAG_HIDDEN);
           if (analog_hour_hand) lv_obj_clear_flag(analog_hour_hand, LV_OBJ_FLAG_HIDDEN);
           if (analog_min_hand) lv_obj_clear_flag(analog_min_hand, LV_OBJ_FLAG_HIDDEN);

           // Calculate hand angles (0° = 12 o'clock, clockwise)
           float hour_angle = (tm->tm_hour % 12) * 30 + tm->tm_min * 0.5;  // 30° per hour + minute offset
           float min_angle = tm->tm_min * 6;  // 6° per minute

           // Convert to radians and calculate endpoints (center at 400,240)
           int cx = 400, cy = 240;
           float hour_rad = (hour_angle - 90) * PI / 180;  // -90° offset (0° at 3 o'clock in LVGL)
           float min_rad = (min_angle - 90) * PI / 180;

           hour_points[0] = {(lv_coord_t)cx, (lv_coord_t)cy};
           hour_points[1] = {
               (lv_coord_t)(cx + 80 * cos(hour_rad)),
               (lv_coord_t)(cy + 80 * sin(hour_rad))
           };
           lv_line_set_points(analog_hour_hand, hour_points, 2);

           min_points[0] = {(lv_coord_t)cx, (lv_coord_t)cy};
           min_points[1] = {
               (lv_coord_t)(cx + 120 * cos(min_rad)),
               (lv_coord_t)(cy + 120 * sin(min_rad))
           };
           lv_line_set_points(analog_min_hand, min_points, 2);
       } else {
           // Show digital, hide analog
           if (clock_time_label) {
               lv_obj_clear_flag(clock_time_label, LV_OBJ_FLAG_HIDDEN);
               lv_label_set_text_fmt(clock_time_label, "%02d:%02d", tm->tm_hour, tm->tm_min);
           }
           if (analog_clock_face) lv_obj_add_flag(analog_clock_face, LV_OBJ_FLAG_HIDDEN);
           if (analog_hour_hand) lv_obj_add_flag(analog_hour_hand, LV_OBJ_FLAG_HIDDEN);
           if (analog_min_hand) lv_obj_add_flag(analog_min_hand, LV_OBJ_FLAG_HIDDEN);
       }

       // Update RSSI indicator (same for both modes)
       if (clock_rssi_label) {
           int rssi = espnow_get_rssi();
           // ... existing RSSI color logic
       }
   }
   ```

3. Call `create_analog_clock_widgets(clock_screen)` in `create_ui()` after creating `clock_screen`.
</action>
<verify>
1. Flash firmware with clock_analog=true in config
2. Enter MODE_CLOCK (long-press brightness button)
3. Verify analog clock displays with hour and minute hands
4. Wait 1 minute, verify minute hand moves
5. Change config to clock_analog=false, reload
6. Verify digital clock displays (existing HH:MM format)
7. Check serial: "Clock mode: analog" or "Clock mode: digital"
</verify>
<done>Clock screen supports both analog and digital rendering. Analog clock uses lv_arc for face and lv_line for hands. Digital clock shows HH:MM text. Mode selected via config.clock_analog.</done>
</task>

<task id="4">
<title>Implement standby mode (minimal standby UI)</title>
<files>display/ui.cpp</files>
<action>
1. Add standby screen:
   ```cpp
   static lv_obj_t *standby_screen = nullptr;
   static lv_obj_t *macro_time_label = nullptr;

   void init_standby_mode() {
       if (!standby_screen) {
           standby_screen = lv_obj_create(NULL);
           lv_obj_set_style_bg_color(standby_screen, lv_color_hex(0x0f0f23), LV_PART_MAIN);

           // Large centered time display
           macro_time_label = lv_label_create(standby_screen);
           lv_label_set_text(macro_time_label, "00:00");
           lv_obj_set_style_text_font(macro_time_label, &lv_font_montserrat_48, LV_PART_MAIN);
           lv_obj_set_style_text_color(macro_time_label, lv_color_white(), LV_PART_MAIN);
           lv_obj_align(macro_time_label, LV_ALIGN_CENTER, 0, -50);

           // Stats row below time (reuse create_stats_header logic but smaller)
           // Or: show minimal stats (CPU%, RAM% only) in compact format
           lv_obj_t *stats = lv_label_create(standby_screen);
           lv_label_set_text(stats, "CPU --% | RAM --% | GPU --%");
           lv_obj_set_style_text_font(stats, &lv_font_montserrat_16, LV_PART_MAIN);
           lv_obj_set_style_text_color(stats, lv_color_hex(0x888888), LV_PART_MAIN);
           lv_obj_align(stats, LV_ALIGN_CENTER, 0, 20);
       }

       // Update time immediately
       time_t now = time(nullptr);
       struct tm *tm = localtime(&now);
       lv_label_set_text_fmt(macro_time_label, "%02d:%02d", tm->tm_hour, tm->tm_min);
   }
   ```

2. Update standby time/stats periodically (in main loop or timer).

3. Macro pad mode is essentially "standby with clock + minimal stats" — no interaction, just display.
</action>
<verify>
1. Flash firmware
2. Enter MODE_STANDBY (long-press brightness button multiple times)
3. Verify large time display centered with stats below
4. Verify stats update when MSG_STATS received
5. Touch screen → should exit to MODE_HOTKEYS
</verify>
<done>Macro pad mode shows large centered time with minimal stats. No interactive buttons. Touch returns to hotkey mode.</done>
</task>

<task id="5">
<title>Implement mode transition handler and UI cleanup</title>
<files>display/ui.cpp</files>
<action>
1. Implement `ui_transition_mode()` function called by `display_set_mode()`:
   ```cpp
   void ui_transition_mode(DisplayMode from, DisplayMode to) {
       // Cleanup previous mode
       switch (from) {
           case MODE_HOTKEYS:
               // Main screen persists, no cleanup needed
               break;

           case MODE_CLOCK:
               // Clock screen persists, just switch away
               break;

           case MODE_PICTURE_FRAME:
               cleanup_picture_frame_mode();  // Stop slideshow timer
               break;

           case MODE_STANDBY:
               // Macro pad screen persists, no cleanup
               break;
       }

       // Initialize and switch to new mode
       switch (to) {
           case MODE_HOTKEYS:
               show_hotkey_view();  // Existing function (loads main_screen)
               break;

           case MODE_CLOCK:
               show_clock_mode();  // Existing function (loads clock_screen)
               update_clock_time();
               break;

           case MODE_PICTURE_FRAME:
               init_picture_frame_mode();
               if (picture_frame_screen) {
                   lv_scr_load(picture_frame_screen);
               }
               break;

           case MODE_STANDBY:
               init_standby_mode();
               if (standby_screen) {
                   lv_scr_load(standby_screen);
               }
               break;
       }

       Serial.printf("Mode transition: %d -> %d complete\n", from, to);
   }
   ```

2. Add long-press detection for brightness button to cycle modes:
   ```cpp
   // In brightness_event_cb or new event handler
   static void brightness_long_press_cb(lv_event_t *e) {
       lv_event_code_t code = lv_event_get_code(e);
       if (code == LV_EVENT_LONG_PRESSED) {
           // Cycle modes: HOTKEYS -> CLOCK -> PICTURE_FRAME -> MACRO_PAD -> HOTKEYS
           DisplayMode current = display_get_mode();
           DisplayMode next = (DisplayMode)((current + 1) % 4);
           display_set_mode(next);
       }
   }

   // Update brightness button event in create_ui_widgets:
   lv_obj_add_event_cb(bright_btn, brightness_long_press_cb, LV_EVENT_LONG_PRESSED, nullptr);
   ```

3. Update touch activity handler to exit non-hotkey modes:
   ```cpp
   // In touch event or power_activity() call
   if (display_get_mode() != MODE_HOTKEYS) {
       display_set_mode(MODE_HOTKEYS);  // Return to main UI on touch
   }
   ```
</action>
<verify>
1. Flash firmware
2. Long-press brightness button, verify mode cycles: HOTKEYS -> CLOCK -> PICTURE_FRAME -> MACRO_PAD -> HOTKEYS
3. In MODE_CLOCK, tap screen, verify returns to MODE_HOTKEYS
4. In MODE_PICTURE_FRAME, wait for slideshow, verify images cycle
5. Long-press brightness to exit picture frame, verify slideshow timer stops
6. Check serial logs for mode transitions
</verify>
<done>Mode transition handler cleans up previous mode and initializes new mode. Long-press brightness button cycles modes. Touch in non-hotkey mode returns to MODE_HOTKEYS.</done>
</task>

<task id="6">
<title>Add display mode configuration to editor and config schema</title>
<files>display/config.h, display/config.cpp, companion/ui/editor_main.py, companion/config_manager.py</files>
<action>
1. In `display/config.cpp`, parse display mode config from JSON:
   ```cpp
   // In config_load():
   config.default_mode = root["default_mode"] | MODE_HOTKEYS;
   config.slideshow_interval_sec = root["slideshow_interval_sec"] | 30;
   config.clock_analog = root["clock_analog"] | false;

   // Validate
   if (config.default_mode > MODE_STANDBY) {
       Serial.printf("WARN: Invalid default_mode=%d, using MODE_HOTKEYS\n", config.default_mode);
       config.default_mode = MODE_HOTKEYS;
   }
   ```

2. In `companion/ui/editor_main.py`, add "Display Modes" config panel:
   - Dropdown: "Default mode on startup" (Hotkeys, Clock, Picture Frame, Standby)
   - Spinbox: "Slideshow interval (seconds)" (range: 5-300, default 30)
   - Checkbox: "Analog clock" (checked = analog, unchecked = digital)
   - Button: "Test picture frame" (shows file browser to select /pictures directory on SD)

3. Wire to config save:
   ```python
   config["default_mode"] = mode_dropdown.currentIndex()  # 0=HOTKEYS, 1=CLOCK, 2=PICTURE_FRAME, 3=MACRO_PAD
   config["slideshow_interval_sec"] = slideshow_spinbox.value()
   config["clock_analog"] = analog_checkbox.isChecked()
   ```

4. In `companion/config_manager.py`, add schema validation:
   ```python
   app_config_schema = {
       "default_mode": {"type": "integer", "minimum": 0, "maximum": 3},
       "slideshow_interval_sec": {"type": "integer", "minimum": 5, "maximum": 300},
       "clock_analog": {"type": "boolean"},
       # ... existing fields
   }
   ```

5. Update README with display mode documentation:
   ```markdown
   ### Display Modes (v0.9.1.6)
   - `default_mode`: 0=Hotkeys, 1=Clock, 2=Picture Frame, 3=Standby
   - `slideshow_interval_sec`: Image change interval for picture frame mode
   - `clock_analog`: true for analog clock, false for digital

   **Mode switching:**
   - Long-press brightness button to cycle modes
   - Touch screen in non-hotkey mode to return to hotkeys
   - Shutdown signal switches to clock mode automatically
   ```
</action>
<verify>
1. Run editor: `python3 -m companion.ui.editor_main config.json`
2. Open Display Modes tab
3. Set default_mode to "Picture Frame", slideshow_interval to 60, analog clock to true
4. Save config, verify JSON: `"default_mode": 2, "slideshow_interval_sec": 60, "clock_analog": true`
5. Upload to display, power cycle
6. Verify display starts in picture frame mode with 60-second interval
7. Long-press brightness, switch to clock, verify analog clock shown
</verify>
<done>Editor has Display Modes config panel with default mode, slideshow interval, and clock style. Config schema validates mode values. README documents mode configuration and switching.</done>
</task>

## Verification

**Picture frame mode:**
1. Create /pictures on SD with 5 JPG images
2. Set default_mode=MODE_PICTURE_FRAME, slideshow_interval=30
3. Upload config, reboot display
4. Verify slideshow starts automatically, cycles every 30 seconds
5. Check LVGL memory monitor: no leaks after 20+ images
6. Test with 800x480 JPEG: verify SJPG decoder handles efficiently

**Analog clock:**
1. Set clock_analog=true
2. Enter MODE_CLOCK
3. Verify clock face with hour and minute hands
4. Wait 1 minute, verify minute hand rotates
5. Check hand angles at 3:15 (hour at ~97.5°, minute at 90°)

**Digital clock:**
1. Set clock_analog=false
2. Enter MODE_CLOCK
3. Verify digital time display (HH:MM format)
4. Existing clock implementation should continue working

**Macro pad mode:**
1. Enter MODE_STANDBY
2. Verify large time + minimal stats display
3. Send MSG_STATS, verify stats update
4. Touch screen, verify returns to MODE_HOTKEYS

**Mode switching:**
1. Long-press brightness button
2. Verify modes cycle: HOTKEYS -> CLOCK -> PICTURE_FRAME -> MACRO_PAD -> HOTKEYS
3. In any non-hotkey mode, tap screen, verify returns to hotkeys
4. Receive MSG_POWER_STATE shutdown, verify switches to MODE_CLOCK

**Backwards compatibility:**
1. Load v0.9.0 config (no display mode fields)
2. Verify defaults to MODE_HOTKEYS with digital clock
3. Save config, verify new fields added

## Success Criteria

- [ ] DisplayMode enum defined in power.h (HOTKEYS, CLOCK, PICTURE_FRAME, MACRO_PAD)
- [ ] display_set_mode() and display_get_mode() API implemented
- [ ] Mode state is orthogonal to PowerState (separate concerns)
- [ ] Picture frame mode displays SD card images in slideshow
- [ ] SJPG decoder enabled for memory-efficient JPEG loading
- [ ] Slideshow timer cycles images at configured interval
- [ ] Analog clock renders with arc face and line hands
- [ ] Digital clock shows HH:MM text (existing implementation)
- [ ] Macro pad mode shows large time + minimal stats
- [ ] Mode transition handler cleans up and initializes modes
- [ ] Long-press brightness button cycles through modes
- [ ] Touch in non-hotkey mode returns to MODE_HOTKEYS
- [ ] Config has default_mode, slideshow_interval_sec, clock_analog fields
- [ ] Editor has Display Modes config panel
- [ ] Config schema validates mode values
- [ ] README documents mode configuration and switching
- [ ] v0.9.0 configs load with default MODE_HOTKEYS
