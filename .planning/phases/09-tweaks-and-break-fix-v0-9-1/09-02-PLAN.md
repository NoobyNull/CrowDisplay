---
phase: 9
plan: 2
title: "Variable Button Sizing (Grid Spans)"
depends_on: [1]
---

# Plan 09-02: Variable Button Sizing with Grid Spans

## Goal
Add col_span and row_span support to ButtonConfig, enabling buttons to occupy 1×1, 2×1, 1×2, or 2×2 grid cells with automatic size calculation.

## Context
Plan 09-01 established grid layout foundation with explicit positioning. This plan extends grid capabilities with `lv_obj_set_grid_cell()` span parameter to support variable button sizes. Requires grid positioning from plan 09-01 (cannot span without explicit position). Editor adds drag-to-resize UI for intuitive button sizing.

**Files affected:**
- `display/config.h` - Add col_span, row_span fields
- `display/config.cpp` - Parse span fields with validation
- `display/ui.cpp` - Apply grid cell spans
- `companion/ui/editor_main.py` - Drag-to-resize button grid UI
- `companion/config_manager.py` - Span constraint validation

## Tasks

<task id="1">
<title>Extend ButtonConfig with col_span and row_span fields</title>
<files>display/config.h, display/config.cpp</files>
<action>
1. In `display/config.h`, add to `ButtonConfig` struct after grid_row/grid_col:
   ```cpp
   uint8_t col_span;  // Column span: 1-4 (default 1)
   uint8_t row_span;  // Row span: 1-3 (default 1)
   ```

2. Update `ButtonConfig()` constructor:
   ```cpp
   ButtonConfig()
       : /* ... existing fields ... */,
         grid_row(-1), grid_col(-1), pressed_color(0x000000),
         col_span(1), row_span(1) {}
   ```

3. In `display/config.cpp`, parse span fields from JSON:
   - `col_span` from "col_span" key (default 1 if missing)
   - `row_span` from "row_span" key (default 1 if missing)

4. Add span validation during config load:
   ```cpp
   // Validate col_span
   if (btn.col_span < 1 || btn.col_span > 4) {
       Serial.printf("WARN: Button col_span=%d invalid, clamping to 1\n", btn.col_span);
       btn.col_span = 1;
   }

   // Validate row_span
   if (btn.row_span < 1 || btn.row_span > 3) {
       Serial.printf("WARN: Button row_span=%d invalid, clamping to 1\n", btn.row_span);
       btn.row_span = 1;
   }

   // Validate span doesn't exceed grid bounds
   if (btn.grid_col >= 0 && btn.grid_col + btn.col_span > 4) {
       Serial.printf("WARN: Button at col %d with span %d exceeds grid, clamping span\n",
                     btn.grid_col, btn.col_span);
       btn.col_span = 4 - btn.grid_col;
   }

   if (btn.grid_row >= 0 && btn.grid_row + btn.row_span > 3) {
       Serial.printf("WARN: Button at row %d with span %d exceeds grid, clamping span\n",
                     btn.grid_row, btn.row_span);
       btn.row_span = 3 - btn.grid_row;
   }
   ```

5. Update `config_save()` to serialize col_span and row_span to JSON.

6. Add design note: Spans only apply to explicitly positioned buttons (grid_row >= 0, grid_col >= 0). Auto-flow buttons ignore span and use 1×1.
</action>
<verify>
1. Build firmware: `pio run -e running`
2. Create test config with button at (1,1) with col_span=2, row_span=2
3. Load config, check serial: "Button 0: pos=(1,1), span=(2,2)"
4. Try invalid config: col_span=5, verify clamped to valid range with warning
5. Try out-of-bounds: grid_col=3, col_span=2, verify clamped to col_span=1
6. Save config, verify JSON has "col_span": 2, "row_span": 2
</verify>
<done>ButtonConfig has col_span and row_span fields. Config parser validates spans and clamps to grid boundaries. Auto-flow buttons ignore spans.</done>
</task>

<task id="2">
<title>Apply grid cell spans in LVGL rendering</title>
<files>display/ui.cpp</files>
<action>
1. In `create_ui_widgets()` button creation loop (after plan 09-01 grid positioning), update `lv_obj_set_grid_cell()` call to use span values:
   ```cpp
   const ButtonConfig& btn_cfg = page.buttons[j];
   lv_obj_t *btn = create_hotkey_button(tab, &btn_cfg);

   if (btn_cfg.grid_row >= 0 && btn_cfg.grid_col >= 0) {
       // Explicit positioning with span
       lv_obj_set_grid_cell(btn,
           LV_GRID_ALIGN_STRETCH, btn_cfg.grid_col, btn_cfg.col_span,  // col: align, pos, span
           LV_GRID_ALIGN_STRETCH, btn_cfg.grid_row, btn_cfg.row_span); // row: align, pos, span
   }
   // Auto-flow buttons still use default 1×1 cell
   ```

2. No changes needed to `create_hotkey_button()` — grid layout automatically sizes button based on spanned cells.

3. Add padding adjustment for large buttons (optional):
   - Increase internal padding for 2×2 buttons to prevent crowding of icon/label/description
   - Example: `if (col_span >= 2 || row_span >= 2) lv_obj_set_style_pad_all(btn, 12, LV_PART_MAIN);`

4. Test layout with mixed button sizes:
   - 4× 1×1 buttons in row 0
   - 1× 2×2 button at (1,0)
   - 2× 1×1 buttons at (1,2) and (1,3)
   - Verify no overlaps or gaps
</action>
<verify>
1. Flash firmware to display
2. Load test config with various span combinations:
   - Button A: pos=(0,0), span=(1,1)
   - Button B: pos=(0,1), span=(2,1) — 2 columns wide
   - Button C: pos=(1,0), span=(1,2) — 2 rows tall
   - Button D: pos=(2,2), span=(2,2) — large 2×2 button
3. Verify on screen:
   - Button B is 2× the width of Button A
   - Button C is 2× the height of Button A
   - Button D occupies 4 grid cells (2×2)
4. Tap all buttons, verify functionality not affected by size
5. Check serial for grid cell allocation errors
</verify>
<done>LVGL grid cell positioning uses col_span and row_span from config. Buttons auto-size to fill spanned cells. No overlaps or clipping issues.</done>
</task>

<task id="3">
<title>Add drag-to-resize UI to editor button grid</title>
<files>companion/ui/editor_main.py</files>
<action>
1. Enhance button grid preview (left side) to show 4×3 grid overlay:
   - Draw grid lines (semi-transparent) over button preview area
   - Each cell represents one grid position
   - Grid is 800×480 scale (match display resolution)

2. Add resize handles to selected button preview:
   - When button is selected, show resize handles (small squares) at corners and edges
   - Bottom-right corner handle enables diagonal resize (both col_span and row_span)
   - Right edge handle enables horizontal resize (col_span only)
   - Bottom edge handle enables vertical resize (row_span only)

3. Implement drag-to-resize interaction:
   - On handle drag, calculate new col_span/row_span based on grid cells covered
   - Clamp to grid boundaries: max col_span = 4 - grid_col, max row_span = 3 - grid_row
   - Update property panel spinboxes in real-time during drag
   - On drag release, save new span values to config

4. Add visual feedback during resize:
   - Show ghost outline of new button size while dragging
   - Display span dimensions as overlay text: "2×2"
   - Highlight grid cells that will be occupied
   - Show warning if resize would exceed grid bounds (red border)

5. Add keyboard shortcuts for resize:
   - Ctrl+Right: increase col_span by 1
   - Ctrl+Left: decrease col_span by 1
   - Ctrl+Down: increase row_span by 1
   - Ctrl+Up: decrease row_span by 1

6. Update property panel with span spinboxes (if not added in plan 09-01):
   - QSpinBox for "Column Span" (range: 1-4, default 1)
   - QSpinBox for "Row Span" (range: 1-3, default 1)
   - Wire to button config updates

7. Add constraint enforcement:
   - If button is auto-flow (grid_row=-1, grid_col=-1), disable resize handles
   - Show tooltip: "Position button explicitly to enable resizing"
   - On resize, if grid_row/grid_col not set, auto-assign to (0,0)
</action>
<verify>
1. Run editor: `python3 -m companion.ui.editor_main config.json`
2. Select a button at position (1,1)
3. Drag bottom-right resize handle to cover 2×2 cells
4. Verify property panel shows col_span=2, row_span=2
5. Save config, open JSON, verify "col_span": 2, "row_span": 2
6. Upload to display, confirm button appears as 2×2
7. Try resizing beyond grid bounds (e.g., from col 3 to span 3 columns), verify clamped to span=1 with visual feedback
8. Try Ctrl+Right keyboard shortcut, verify col_span increases
</verify>
<done>Editor has drag-to-resize handles on button preview. Resizing updates col_span/row_span in property panel and config. Visual feedback shows grid coverage. Constraints prevent exceeding grid bounds.</done>
</task>

<task id="4">
<title>Add span validation and conflict detection</title>
<files>companion/config_manager.py</files>
<action>
1. In `companion/config_manager.py`, extend JSON schema validation:
   ```python
   button_schema = {
       "col_span": {"type": "integer", "minimum": 1, "maximum": 4},
       "row_span": {"type": "integer", "minimum": 1, "maximum": 3},
       # ... existing fields from plan 09-01
   }
   ```

2. Add grid occupancy validation:
   ```python
   def validate_button_layout(page_config):
       """Check for overlapping buttons in grid layout."""
       grid = [[None for _ in range(4)] for _ in range(3)]  # 3 rows, 4 cols

       for btn_idx, btn in enumerate(page_config["buttons"]):
           if btn.get("grid_row", -1) < 0 or btn.get("grid_col", -1) < 0:
               continue  # Skip auto-flow buttons

           row = btn["grid_row"]
           col = btn["grid_col"]
           col_span = btn.get("col_span", 1)
           row_span = btn.get("row_span", 1)

           # Check if button exceeds grid bounds
           if col + col_span > 4:
               raise ValueError(f"Button {btn_idx} exceeds grid width: col {col} + span {col_span} > 4")
           if row + row_span > 3:
               raise ValueError(f"Button {btn_idx} exceeds grid height: row {row} + span {row_span} > 3")

           # Check for overlaps with existing buttons
           for r in range(row, row + row_span):
               for c in range(col, col + col_span):
                   if grid[r][c] is not None:
                       raise ValueError(f"Button {btn_idx} overlaps with button {grid[r][c]} at cell ({r},{c})")
                   grid[r][c] = btn_idx
   ```

3. Call `validate_button_layout()` in config load and save paths.

4. Add auto-fix option (optional):
   - If overlap detected, offer to auto-adjust positions
   - Or: remove spans and fall back to 1×1 for conflicting buttons
   - Log warning: "Button overlap detected, span reduced to fit"

5. Update README.md with layout rules:
   ```markdown
   ### Button Sizing (v0.9.1.3)
   - `col_span`: 1-4 columns (default 1)
   - `row_span`: 1-3 rows (default 1)
   - Spans only apply to explicitly positioned buttons (grid_row ≥ 0, grid_col ≥ 0)
   - Buttons cannot overlap or exceed 4×3 grid bounds
   ```
</action>
<verify>
1. Create test config with overlapping buttons:
   - Button A: pos=(0,0), span=(2,2)
   - Button B: pos=(1,1), span=(1,1)  — overlaps with A
2. Try loading config, verify error: "Button 1 overlaps with button 0 at cell (1,1)"
3. Fix overlap, reload, verify no errors
4. Check README has span documentation
</verify>
<done>Config validation detects button overlaps and out-of-bounds spans. README documents sizing constraints. Invalid configs rejected with clear error messages.</done>
</task>

## Verification

**Variable sizing:**
1. Create config with buttons of various sizes: 1×1, 2×1, 1×2, 2×2
2. Upload to display, verify visual sizes match configuration
3. All buttons render without clipping or gaps

**Editor resize workflow:**
1. Open editor, select button at (1,1)
2. Drag resize handle to 2×2
3. Save, upload, verify on display

**Constraint enforcement:**
1. Try creating 2×2 button at position (3,2) — would exceed grid
2. Verify editor clamps to valid span or shows error
3. Config validation rejects invalid layouts

**Backwards compatibility:**
1. Load v0.9.1.1 config (has grid_row/grid_col, no spans)
2. Verify buttons render as 1×1 (default span)
3. Save config, verify span fields added with defaults

## Success Criteria

- [ ] ButtonConfig has col_span and row_span fields (default 1)
- [ ] Config parser validates spans and clamps to grid bounds
- [ ] LVGL grid cell positioning uses span parameters
- [ ] Buttons auto-size to fill spanned cells (no manual pixel sizing)
- [ ] Editor has drag-to-resize handles on button preview
- [ ] Property panel has span spinboxes
- [ ] Resize updates config and shows visual feedback
- [ ] Config validation detects overlapping buttons
- [ ] Out-of-bounds spans are rejected or clamped
- [ ] README documents span fields and constraints
- [ ] v0.9.1.1 configs load with default 1×1 spans
