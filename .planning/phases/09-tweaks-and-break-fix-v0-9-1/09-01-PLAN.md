---
phase: 9
plan: 1
title: "Grid Layout + Positioning + Pressed Color"
depends_on: []
---

# Plan 09-01: Grid Layout Foundation with Positioning and Pressed Color

## Goal
Replace flex layout with LVGL grid layout to enable explicit button positioning and add configurable pressed color for individual button visual feedback.

## Context
Current implementation uses `LV_FLEX_FLOW_ROW_WRAP` with fixed 170x90 buttons and auto-darkened pressed state. This plan migrates to LVGL v8.3 grid layout (4 columns × 3 rows) with explicit grid_row/grid_col positioning support and per-button pressed color configuration. This is the foundation for variable sizing (plan 09-02).

**Files affected:**
- `display/config.h` - Add grid_row, grid_col, pressed_color fields
- `display/config.cpp` - Parse new JSON fields with defaults
- `display/ui.cpp` - Replace flex layout with grid layout, apply pressed color
- `companion/ui/editor_main.py` - Add position/pressed color controls to property panel
- `companion/config_manager.py` - Schema validation for new fields

## Tasks

<task id="1">
<title>Extend ButtonConfig schema with positioning and pressed color</title>
<files>display/config.h, display/config.cpp</files>
<action>
1. In `display/config.h`, add to `ButtonConfig` struct:
   ```cpp
   // Grid positioning (optional, defaults to auto-flow)
   int8_t grid_row;         // -1 = auto-flow (default), 0-2 = explicit row
   int8_t grid_col;         // -1 = auto-flow (default), 0-3 = explicit column
   uint32_t pressed_color;  // 0x000000 = auto-darken (default), else explicit color
   ```

2. Update `ButtonConfig()` constructor to initialize:
   ```cpp
   ButtonConfig()
       : label(""), description(""), color(0xFFFFFF), icon(""),
         action_type(ACTION_HOTKEY), modifiers(0), keycode(0), consumer_code(0),
         grid_row(-1), grid_col(-1), pressed_color(0x000000) {}
   ```

3. In `display/config.cpp`, parse new fields from JSON with defaults:
   - `grid_row` from "grid_row" key (default -1 if missing)
   - `grid_col` from "grid_col" key (default -1 if missing)
   - `pressed_color` from "pressed_color" key (default 0x000000 if missing)

4. Validate constraints during load:
   - `grid_row` must be in range [-1, 2]
   - `grid_col` must be in range [-1, 3]
   - If both grid_row and grid_col are -1, button uses auto-flow
   - If either is explicit (>= 0), both must be explicit
   - Log warning if invalid, clamp to valid range

5. Update `config_save()` to serialize new fields to JSON.

6. Remove `CONFIG_MAX_BUTTONS` fixed limit enforcement — pages can now have 1 to 12 buttons (or fewer). The grid auto-flows any count. Validate only that pages have at least 1 button and no more than 12 (4×3 grid capacity). Log the actual count: `"Page '%s': %d buttons loaded"`.
</action>
<verify>
1. Build firmware: `pio run -e running`
2. Load test config with grid_row/grid_col/pressed_color fields
3. Check serial output confirms parsing: "Button 0: grid_pos=(1,2), pressed=0xFF5733"
4. Save config and verify JSON contains new fields with correct values
</verify>
<done>ButtonConfig struct has grid_row, grid_col, pressed_color fields. Config load/save handles new fields with proper defaults and validation.</done>
</task>

<task id="2">
<title>Replace flex layout with LVGL grid layout in UI rendering</title>
<files>display/ui.cpp</files>
<action>
1. In `create_ui_widgets()`, replace flex layout setup (lines 463-467) with grid layout:
   ```cpp
   // Define 4-column, 3-row grid with equal fractional units
   static lv_coord_t col_dsc[] = {LV_GRID_FR(1), LV_GRID_FR(1), LV_GRID_FR(1), LV_GRID_FR(1), LV_GRID_TEMPLATE_LAST};
   static lv_coord_t row_dsc[] = {LV_GRID_FR(1), LV_GRID_FR(1), LV_GRID_FR(1), LV_GRID_TEMPLATE_LAST};

   lv_obj_set_layout(tab, LV_LAYOUT_GRID);
   lv_obj_set_grid_dsc_array(tab, col_dsc, row_dsc);
   ```

2. Remove `lv_obj_set_flex_flow()`, `lv_obj_set_flex_align()` calls for tab object.

3. In button creation loop, after `create_hotkey_button()`, position button in grid:
   ```cpp
   const ButtonConfig& btn_cfg = page.buttons[j];
   lv_obj_t *btn = create_hotkey_button(tab, &btn_cfg);

   if (btn_cfg.grid_row >= 0 && btn_cfg.grid_col >= 0) {
       // Explicit positioning
       lv_obj_set_grid_cell(btn,
           LV_GRID_ALIGN_STRETCH, btn_cfg.grid_col, 1,  // col: align, pos, span
           LV_GRID_ALIGN_STRETCH, btn_cfg.grid_row, 1); // row: align, pos, span
   }
   // else: auto-flow (no positioning call needed)
   ```

4. In `create_hotkey_button()`, replace hardcoded button size (line 106):
   ```cpp
   // Remove: lv_obj_set_size(btn, 170, 90);
   // Grid layout auto-sizes based on cell dimensions
   ```

5. Update pressed color styling (lines 120-122):
   ```cpp
   lv_color_t pressed_color;
   if (btn_cfg->pressed_color == 0x000000) {
       // Auto-darken if not explicitly set
       pressed_color = lv_color_darken(lv_color_hex(btn_cfg->color), LV_OPA_30);
   } else {
       // Use explicit pressed color
       pressed_color = lv_color_hex(btn_cfg->pressed_color);
   }
   lv_obj_set_style_bg_color(btn, pressed_color, LV_STATE_PRESSED);
   ```

6. Keep transform shrink effect on press for tactile feedback.

7. Ensure pages with fewer than 12 buttons render correctly — auto-flow fills available cells, empty cells remain blank. No dummy/placeholder buttons needed.
</action>
<verify>
1. Flash updated firmware to display
2. Load config with mix of positioned and auto-flow buttons
3. Verify buttons appear in correct grid positions
4. Tap buttons, confirm pressed color matches config (custom or auto-darkened)
5. Check serial: "UI initialized: N page(s)" without errors
6. Verify grid auto-sizes buttons to fill 800x480 screen area
</verify>
<done>UI uses grid layout with 4×3 cells. Buttons with grid_row/grid_col are explicitly positioned. Buttons with -1/-1 use auto-flow. Pressed color respects per-button configuration or auto-darkens.</done>
</task>

<task id="3">
<title>Add positioning and pressed color controls to PySide6 editor</title>
<files>companion/ui/editor_main.py</files>
<action>
1. In property panel (right side), add grid positioning controls:
   - QSpinBox for "Grid Row" (range: -1 to 2, default -1, -1 = "Auto")
   - QSpinBox for "Grid Column" (range: -1 to 3, default -1, -1 = "Auto")
   - Label explaining: "Set both to ≥0 for explicit position, or -1/-1 for auto-flow"

2. Add pressed color picker below normal color picker:
   - QColorButton for "Pressed Color" (default black = auto-darken)
   - Checkbox: "Auto-darken" (when checked, sets color to 0x000000)
   - When unchecked, show color picker dialog

3. Wire property panel updates to ButtonConfig:
   - On grid_row/grid_col change, update button config and save
   - On pressed_color change, update button config and save
   - Validate: if grid_row >= 0, grid_col must be >= 0 (show warning if violated)

4. Add visual feedback in button grid preview:
   - Show grid lines (4×3 overlay) when in positioning mode
   - Highlight selected button's grid cell with border
   - Optionally: drag-and-drop buttons to grid cells (sets grid_row/grid_col)

5. Update button preview to show pressed color:
   - On mouse press, briefly flash pressed color instead of normal color
   - Or: add tooltip showing "Pressed: #FF5733" on hover
</action>
<verify>
1. Run editor: `python3 -m companion.ui.editor_main config.json`
2. Select a button, set grid_row=1, grid_col=2
3. Set pressed_color to red (#FF0000)
4. Save config, open in text editor, verify JSON has:
   ```json
   "grid_row": 1, "grid_col": 2, "pressed_color": 16711680
   ```
5. Upload to display, tap button, confirm it appears at row 1, col 2 with red pressed state
</verify>
<done>Editor has grid positioning spinboxes and pressed color picker in property panel. Button grid preview shows grid overlay. Config saves grid_row, grid_col, pressed_color correctly.</done>
</task>

<task id="4">
<title>Update config schema validation and documentation</title>
<files>companion/config_manager.py, README.md</files>
<action>
1. In `companion/config_manager.py`, add JSON schema validation for new fields:
   ```python
   button_schema = {
       "grid_row": {"type": "integer", "minimum": -1, "maximum": 2},
       "grid_col": {"type": "integer", "minimum": -1, "maximum": 3},
       "pressed_color": {"type": "integer", "minimum": 0, "maximum": 0xFFFFFF},
       # ... existing fields
   }
   ```

2. Add validation rule:
   - If `grid_row >= 0 or grid_col >= 0`, both must be in valid range [0, max]
   - Reject configs with grid_row=1, grid_col=-1 (partial positioning)

3. Update README.md with new config options:
   ```markdown
   ### Button Positioning (v0.9.1.1)
   - `grid_row`: -1 for auto-flow, 0-2 for explicit row
   - `grid_col`: -1 for auto-flow, 0-3 for explicit column
   - Both must be set together for explicit positioning

   ### Pressed Color (v0.9.1.2)
   - `pressed_color`: 0x000000 for auto-darken, or explicit RGB hex color
   ```

4. Add migration note for existing configs:
   - v0.9.0 configs without these fields will default to auto-flow and auto-darken
   - No manual migration needed
</action>
<verify>
1. Load v0.9.0 config (without new fields), verify defaults applied
2. Save config, verify new fields present with defaults
3. Try loading invalid config (grid_row=1, grid_col=-1), verify error message
4. Check README has updated config reference
</verify>
<done>Config schema validates grid_row, grid_col, pressed_color constraints. README documents new fields. Migration from v0.9.0 configs is automatic.</done>
</task>

## Verification

**Config-driven positioning:**
1. Create test config with 4 buttons: auto-flow, explicit (0,0), explicit (1,2), explicit (2,3)
2. Upload to display, verify layout matches grid positions
3. All buttons auto-size to fill grid cells evenly

**Pressed color:**
1. Create test config with 3 buttons: auto-darken, red press, blue press
2. Tap each button, verify pressed state color matches config
3. Auto-darken buttons show darker version of normal color

**Editor workflow:**
1. Open editor, create new button
2. Set grid position via spinboxes, pressed color via picker
3. Save, upload, verify on display

**Backwards compatibility:**
1. Load v0.9.0 config (no grid_row/grid_col/pressed_color fields)
2. Verify UI renders with auto-flow layout (same as v0.9.0)
3. Save config, verify new fields added with defaults

## Success Criteria

- [ ] ButtonConfig has grid_row, grid_col, pressed_color fields
- [ ] Config load/save handles new fields with validation
- [ ] Grid layout replaces flex layout (4×3 grid)
- [ ] Buttons with grid_row/grid_col >= 0 are explicitly positioned
- [ ] Buttons with grid_row/grid_col = -1 use auto-flow
- [ ] Pressed color respects per-button config or auto-darkens
- [ ] Editor has positioning and pressed color controls
- [ ] Config schema validates constraints (both row/col set together)
- [ ] README documents new config fields
- [ ] v0.9.0 configs load with automatic defaults
