---
phase: 9
plan: 5
title: "Host OS Notification Forwarding"
depends_on: [3]
---

# Plan 09-05: Desktop Notification Forwarding to Display

## Goal
Forward host OS desktop notifications to the display as toast overlays with configurable app filtering, using D-Bus session bus monitoring and a new MSG_NOTIFICATION protocol message.

## Context
Plan 09-03 established the TLV protocol pattern and expanded MSG_STATS. This plan adds a parallel notification path: companion monitors D-Bus `org.freedesktop.Notifications` on the session bus, filters by user-configured app names, and sends matching notifications to the display via MSG_NOTIFICATION through the bridge. Display shows notifications as auto-dismissing toast overlays.

**Files affected:**
- `shared/protocol.h` - Add MSG_NOTIFICATION type and NotificationMsg struct
- `companion/hotkey_companion.py` - D-Bus notification listener with app filtering
- `bridge/bridge.ino` - Relay MSG_NOTIFICATION over ESP-NOW
- `display/ui.cpp` - Toast notification overlay widget
- `display/ui.h` - Public API for notification display
- `companion/ui/editor_main.py` - Notification filter config panel
- `companion/config_manager.py` - Notification config schema

## Tasks

<task id="1">
<title>Define MSG_NOTIFICATION protocol message</title>
<files>shared/protocol.h</files>
<action>
1. Add notification message type to `MsgType` enum:
   ```cpp
   MSG_NOTIFICATION = 0x08,  // Bridge -> Display: desktop notification
   ```

2. Define notification payload struct:
   ```cpp
   struct __attribute__((packed)) NotificationMsg {
       char app_name[32];   // Source app (null-terminated, truncated)
       char summary[100];   // Notification title
       char body[116];      // Notification body (truncated to fit)
   };
   // Total: 248 bytes, fits within 250-byte ESP-NOW limit
   ```

3. Verify sizeof(NotificationMsg) = 248 at compile time with static_assert.
</action>
<verify>
1. Build both firmware targets
2. Verify sizeof check passes
3. Check MSG_NOTIFICATION = 0x08 doesn't conflict with existing types
</verify>
<done>protocol.h defines MSG_NOTIFICATION and NotificationMsg struct (248 bytes).</done>
</task>

<task id="2">
<title>Implement D-Bus notification listener with app filtering in companion</title>
<files>companion/hotkey_companion.py</files>
<action>
1. Add D-Bus notification monitoring using dbus-next (already a dependency):
   ```python
   import asyncio
   import threading
   from dbus_next.aio import MessageBus
   from dbus_next import BusType, MessageType

   class NotificationListener:
       def __init__(self, app_filter: set, callback):
           self.app_filter = app_filter  # e.g., {"Slack", "Discord", "thunderbird"}
           self.callback = callback
           self._bus = None

       async def run(self):
           self._bus = await MessageBus(bus_type=BusType.SESSION).connect()

           # Add match rule to intercept Notify method calls
           reply = await self._bus.call(
               Message(
                   destination='org.freedesktop.DBus',
                   path='/org/freedesktop/DBus',
                   interface='org.freedesktop.DBus',
                   member='AddMatch',
                   signature='s',
                   body=["type='method_call',interface='org.freedesktop.Notifications',member='Notify'"]
               )
           )

           def message_filter(msg):
               if (msg.message_type == MessageType.METHOD_CALL and
                   msg.interface == 'org.freedesktop.Notifications' and
                   msg.member == 'Notify'):
                   args = msg.body
                   if len(args) >= 5:
                       app_name = args[0]  # string
                       summary = args[3]   # string
                       body = args[4]      # string

                       # Apply app filter
                       if not self.app_filter or app_name in self.app_filter:
                           self.callback(app_name, summary, body)

           self._bus.add_message_handler(message_filter)
           await self._bus.wait_for_disconnect()
   ```

2. Add notification send function:
   ```python
   def send_notification_to_display(device, app_name, summary, body):
       app_bytes = app_name.encode('utf-8')[:31] + b'\x00'
       sum_bytes = summary.encode('utf-8')[:99] + b'\x00'
       body_bytes = body.encode('utf-8')[:115] + b'\x00'

       payload = (app_bytes.ljust(32, b'\x00') +
                  sum_bytes.ljust(100, b'\x00') +
                  body_bytes.ljust(116, b'\x00'))

       device.write(b"\x00" + bytes([MSG_NOTIFICATION]) + payload)
   ```

3. Load notification_filter from config.json (list of app name strings). If empty list, forward all notifications.

4. Start listener in daemon thread from main():
   ```python
   filter_set = set(config.get("notification_filter", []))
   listener = NotificationListener(filter_set, lambda app, s, b: send_notification_to_display(device, app, s, b))
   threading.Thread(target=lambda: asyncio.run(listener.run()), daemon=True).start()
   ```

5. Add error handling: if D-Bus connection fails (no session bus, no permission), log warning and continue without notifications.

6. Note: D-Bus eavesdrop may require `busctl monitor` or policy adjustment. Document in README the D-Bus policy snippet if needed:
   ```xml
   <!-- /etc/dbus-1/session.d/crowpanel-notifications.conf -->
   <busconfig>
     <policy context="default">
       <allow eavesdrop="true"/>
     </policy>
   </busconfig>
   ```
</action>
<verify>
1. Run companion with notification_filter: ["Slack"]
2. Trigger a Slack notification on the host
3. Check companion logs: "Forwarding notification: Slack - New message"
4. Verify HID report sent with MSG_NOTIFICATION payload
5. Trigger a Discord notification (not in filter), verify NOT forwarded
6. Test with empty filter (forward all), verify all notifications forwarded
</verify>
<done>Companion monitors D-Bus session bus for desktop notifications. App filter controls which apps are forwarded. Notifications encoded as 248-byte MSG_NOTIFICATION payloads.</done>
</task>

<task id="3">
<title>Add bridge relay for MSG_NOTIFICATION</title>
<files>bridge/bridge.ino</files>
<action>
1. In bridge message handler (where MSG_STATS is relayed from USB HID to ESP-NOW), add MSG_NOTIFICATION case:
   ```cpp
   case MSG_NOTIFICATION:
       // Relay notification from companion (USB HID) to display (ESP-NOW)
       espnow_send(payload, len);
       Serial.printf("Relay: notification (%d bytes)\n", len);
       break;
   ```

2. No special handling needed — same relay pattern as MSG_STATS and MSG_POWER_STATE.
</action>
<verify>
1. Build bridge firmware
2. Send MSG_NOTIFICATION from companion
3. Check bridge serial: "Relay: notification (248 bytes)"
4. Verify ESP-NOW transmit succeeds (248 bytes < 250 byte limit)
</verify>
<done>Bridge relays MSG_NOTIFICATION from USB HID to ESP-NOW. Same pattern as existing message relay.</done>
</task>

<task id="4">
<title>Implement toast notification overlay on display</title>
<files>display/ui.cpp, display/ui.h</files>
<action>
1. Add public API to ui.h:
   ```cpp
   void show_notification_toast(const char *app_name, const char *summary, const char *body);
   ```

2. Implement toast overlay in ui.cpp:
   ```cpp
   static lv_obj_t *active_toast = nullptr;  // Track active toast for replacement

   void show_notification_toast(const char *app_name, const char *summary, const char *body) {
       // Remove existing toast if present (prevents stacking)
       if (active_toast) {
           lv_obj_del(active_toast);
           active_toast = nullptr;
       }

       // Create toast container (top of screen, no modal background)
       lv_obj_t *toast = lv_obj_create(lv_scr_act());
       lv_obj_set_size(toast, 600, 120);
       lv_obj_align(toast, LV_ALIGN_TOP_RIGHT, -20, 50);
       lv_obj_set_style_bg_color(toast, lv_color_hex(0x1a1a2e), LV_PART_MAIN);
       lv_obj_set_style_bg_opa(toast, LV_OPA_90, LV_PART_MAIN);
       lv_obj_set_style_border_color(toast, lv_color_hex(0x3498DB), LV_PART_MAIN);
       lv_obj_set_style_border_width(toast, 2, LV_PART_MAIN);
       lv_obj_set_style_radius(toast, 12, LV_PART_MAIN);
       lv_obj_set_style_shadow_width(toast, 12, LV_PART_MAIN);
       lv_obj_set_style_shadow_opa(toast, LV_OPA_40, LV_PART_MAIN);
       lv_obj_clear_flag(toast, LV_OBJ_FLAG_SCROLLABLE);

       // App name header
       lv_obj_t *app_lbl = lv_label_create(toast);
       lv_label_set_text(app_lbl, app_name);
       lv_obj_set_style_text_font(app_lbl, &lv_font_montserrat_14, LV_PART_MAIN);
       lv_obj_set_style_text_color(app_lbl, lv_color_hex(0x3498DB), LV_PART_MAIN);
       lv_obj_align(app_lbl, LV_ALIGN_TOP_LEFT, 12, 8);

       // Summary (title)
       lv_obj_t *sum_lbl = lv_label_create(toast);
       lv_label_set_text(sum_lbl, summary);
       lv_obj_set_style_text_font(sum_lbl, &lv_font_montserrat_16, LV_PART_MAIN);
       lv_obj_set_style_text_color(sum_lbl, lv_color_white(), LV_PART_MAIN);
       lv_obj_align(sum_lbl, LV_ALIGN_TOP_LEFT, 12, 28);

       // Body text (if present)
       if (body && strlen(body) > 0) {
           lv_obj_t *body_lbl = lv_label_create(toast);
           lv_label_set_text(body_lbl, body);
           lv_label_set_long_mode(body_lbl, LV_LABEL_LONG_DOT);
           lv_obj_set_width(body_lbl, 560);
           lv_obj_set_style_text_font(body_lbl, &lv_font_montserrat_12, LV_PART_MAIN);
           lv_obj_set_style_text_color(body_lbl, lv_color_hex(0xBBBBBB), LV_PART_MAIN);
           lv_obj_align(body_lbl, LV_ALIGN_TOP_LEFT, 12, 52);
       }

       // Tap to dismiss
       lv_obj_add_flag(toast, LV_OBJ_FLAG_CLICKABLE);
       lv_obj_add_event_cb(toast, [](lv_event_t *e) {
           lv_obj_t *obj = lv_event_get_target(e);
           lv_obj_del(obj);
           active_toast = nullptr;
       }, LV_EVENT_CLICKED, nullptr);

       // Auto-dismiss after 5 seconds with fade-out
       lv_anim_t a;
       lv_anim_init(&a);
       lv_anim_set_var(&a, toast);
       lv_anim_set_values(&a, LV_OPA_90, LV_OPA_TRANSP);
       lv_anim_set_exec_cb(&a, (lv_anim_exec_xcb_t)lv_obj_set_style_opa);
       lv_anim_set_time(&a, 300);
       lv_anim_set_delay(&a, 5000);
       lv_anim_set_ready_cb(&a, [](lv_anim_t *anim) {
           lv_obj_del((lv_obj_t*)anim->var);
           active_toast = nullptr;
       });
       lv_anim_start(&a);

       active_toast = toast;
   }
   ```

3. Add MSG_NOTIFICATION handler in the display message receive path (wherever MSG_STATS is handled in main.cpp):
   ```cpp
   case MSG_NOTIFICATION: {
       NotificationMsg *notif = (NotificationMsg*)payload;
       notif->app_name[31] = '\0';
       notif->summary[99] = '\0';
       notif->body[115] = '\0';
       show_notification_toast(notif->app_name, notif->summary, notif->body);
       break;
   }
   ```
</action>
<verify>
1. Flash firmware
2. Send test notification from companion
3. Verify toast appears top-right below header
4. Verify auto-dismiss after 5 seconds with fade
5. Tap toast, verify immediate dismiss
6. Send 2 rapid notifications, verify second replaces first (no stacking)
7. Check LVGL memory: no leak after 20 toast cycles
</verify>
<done>Display shows notification toasts as styled overlays. Auto-dismiss after 5s, tap to dismiss. Latest notification replaces previous. No memory leaks.</done>
</task>

<task id="5">
<title>Add notification filter configuration to editor</title>
<files>companion/ui/editor_main.py, companion/config_manager.py</files>
<action>
1. Add "Notifications" config panel to editor:
   - Checkbox: "Enable notification forwarding" (controls whether listener starts)
   - QListWidget: "Forwarded apps" showing configured app names
   - QLineEdit + "Add" button to add new app names
   - "Remove" button to remove selected app
   - Example placeholder text: "e.g., Slack, Discord, Thunderbird, Signal"
   - Note: empty list = forward ALL notifications

2. Wire to config:
   ```python
   config["notifications_enabled"] = enabled_checkbox.isChecked()
   config["notification_filter"] = [item.text() for item in list_widget items]
   ```

3. Add schema validation in config_manager.py:
   - notification_filter: array of strings
   - notifications_enabled: boolean

4. Show info tooltip: "App names must match exactly as they appear in D-Bus notifications. Run `dbus-monitor --session interface=org.freedesktop.Notifications` to discover app names."
</action>
<verify>
1. Run editor, open Notifications tab
2. Enable notifications, add "Slack" and "Discord" to filter list
3. Save config, verify JSON: `"notifications_enabled": true, "notification_filter": ["Slack", "Discord"]`
4. Upload to display via config server
5. Verify companion reads filter and applies it
</verify>
<done>Editor has Notifications config panel with enable toggle and app filter list. Config saves notification_filter array and notifications_enabled flag.</done>
</task>

## Verification

**End-to-end notification flow:**
1. Configure notification_filter: ["Slack"]
2. Upload config to display
3. Restart companion
4. Trigger Slack notification on host PC
5. Verify: companion intercepts → HID report → bridge relays → display shows toast

**App filtering:**
1. Set filter to ["Slack", "Discord"]
2. Trigger Slack notification → forwarded
3. Trigger Firefox notification → NOT forwarded
4. Set filter to [] (empty) → ALL forwarded

**Toast overlay:**
1. Verify toast positioned top-right, doesn't block hotkey buttons
2. Verify auto-dismiss after 5 seconds
3. Verify tap-to-dismiss works
4. Verify rapid notifications replace (not stack)

**Backwards compatibility:**
1. Load config without notification fields → disabled by default
2. Companion runs without error if D-Bus unavailable

## Success Criteria

- [ ] protocol.h defines MSG_NOTIFICATION and NotificationMsg (248 bytes)
- [ ] Companion monitors D-Bus session bus for org.freedesktop.Notifications
- [ ] App filter controls which notifications are forwarded
- [ ] Bridge relays MSG_NOTIFICATION over ESP-NOW
- [ ] Display shows toast overlay with app name, summary, body
- [ ] Toast auto-dismisses after 5 seconds or on tap
- [ ] Rapid notifications replace (not stack) — no memory leak
- [ ] Editor has notification config panel with enable toggle and app filter
- [ ] D-Bus failure is graceful (log warning, continue without notifications)
- [ ] Config defaults to notifications disabled
