---
phase: 04-battery-management-power-states
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/protocol.h
  - display/battery.h
  - display/battery.cpp
  - display/power.h
  - display/power.cpp
  - display/display_hw.h
  - display/display_hw.cpp
  - platformio.ini
autonomous: true

must_haves:
  truths:
    - "Battery module initializes on I2C bus with mutex protection and reads percent/voltage (or reports unavailable if no fuel gauge)"
    - "Power state machine transitions between ACTIVE, DIMMED, and CLOCK_MODE states based on idle timeout, shutdown signal, and wake detection"
    - "Brightness can be set programmatically via set_backlight() wrapper around lcd.setBrightness()"
    - "Protocol defines MSG_POWER_STATE and MSG_TIME_SYNC message types with packed structs"
  artifacts:
    - path: "shared/protocol.h"
      provides: "MSG_POWER_STATE (0x05), MSG_TIME_SYNC (0x06), PowerStateMsg, TimeSyncMsg structs"
      contains: "MSG_POWER_STATE"
    - path: "display/battery.h"
      provides: "battery_init(), battery_read() -> BatteryState"
      contains: "BatteryState"
    - path: "display/battery.cpp"
      provides: "MAX17048 fuel gauge I2C polling with mutex protection"
      contains: "i2c_mutex"
    - path: "display/power.h"
      provides: "PowerState enum, power_init/update/activity/shutdown/wake functions"
      contains: "PowerState"
    - path: "display/power.cpp"
      provides: "State machine implementation with brightness transitions"
      contains: "POWER_ACTIVE"
    - path: "display/display_hw.h"
      provides: "set_backlight(), get_backlight() declarations"
      contains: "set_backlight"
    - path: "display/display_hw.cpp"
      provides: "Brightness wrapper using lcd.setBrightness()"
      contains: "setBrightness"
  key_links:
    - from: "display/battery.cpp"
      to: "display/touch.h"
      via: "I2C mutex (i2c_mutex from touch.h)"
      pattern: "xSemaphoreTake.*i2c_mutex"
    - from: "display/power.cpp"
      to: "display/display_hw.h"
      via: "set_backlight() for brightness transitions"
      pattern: "set_backlight"
---

<objective>
Add protocol messages for power state signaling and time sync, create battery monitoring module (MAX17048 I2C fuel gauge with graceful degradation), implement the three-state power state machine (ACTIVE/DIMMED/CLOCK_MODE), and add brightness control wrappers to display hardware layer.

Purpose: Establish the firmware foundation that all other Phase 4 plans build on -- protocol types, battery reading, power state logic, and brightness control.
Output: Compilable protocol header, battery module, power state machine, and brightness API ready for UI integration.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@shared/protocol.h
@display/display_hw.h
@display/display_hw.cpp
@display/touch.h
@platformio.ini
@.planning/phases/04-battery-management-power-states/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protocol extension + battery module</name>
  <files>
    shared/protocol.h
    display/battery.h
    display/battery.cpp
    platformio.ini
  </files>
  <action>
1. In `shared/protocol.h`, add two new message types to the MsgType enum:
   - `MSG_POWER_STATE = 0x05` (Bridge -> Display: PC power state change)
   - `MSG_TIME_SYNC   = 0x06` (Bridge -> Display: epoch time from companion)

   Add two new payload structs:
   ```cpp
   struct __attribute__((packed)) PowerStateMsg {
       uint8_t state;  // 0 = PC_SHUTDOWN, 1 = PC_WAKE
   };

   struct __attribute__((packed)) TimeSyncMsg {
       uint32_t epoch_seconds;  // Unix timestamp from companion
   };
   ```

   Add defines: `#define POWER_SHUTDOWN 0` and `#define POWER_WAKE 1`.

2. In `platformio.ini`, add the SparkFun MAX1704x library to env:display lib_deps:
   ```
   sparkfun/SparkFun MAX1704x Fuel Gauge Arduino Library@^1.0.4
   ```

3. Create `display/battery.h` with:
   ```cpp
   #pragma once
   #include <cstdint>

   struct BatteryState {
       uint8_t percent;    // 0-100, or 0xFF if unavailable
       float   voltage;    // Volts (e.g., 3.85), 0.0 if unavailable
       bool    available;  // false if no fuel gauge detected
   };

   bool battery_init();            // Init MAX17048 on I2C bus (mutex-protected). Returns true if found.
   BatteryState battery_read();    // Read current state (mutex-protected). Call every 10-30s, not every loop.
   ```

4. Create `display/battery.cpp`:
   - Include SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h, touch.h (for i2c_mutex), Arduino.h
   - Static `SFE_MAX1704X lipo(MAX1704X_MAX17048)` and `static bool fuel_gauge_present = false`
   - `battery_init()`: Take i2c_mutex with 50ms timeout, call `lipo.begin()`, release mutex. Set `fuel_gauge_present` based on result. Print status to Serial. Return bool.
   - `battery_read()`: If `!fuel_gauge_present`, return `{0xFF, 0.0f, false}`. Otherwise take i2c_mutex (50ms), read `lipo.getVoltage()` and `lipo.getSOC()`, release mutex. Return BatteryState with percent clamped to 0-100 via `constrain()`, voltage from getVoltage(), available=true.
   - CRITICAL: ALL I2C access must use `xSemaphoreTake(i2c_mutex, pdMS_TO_TICKS(50))` / `xSemaphoreGive(i2c_mutex)` from touch.h. This prevents GT911 touch corruption.
  </action>
  <verify>
    `pio run -e display` compiles without errors. Check that protocol.h has MSG_POWER_STATE and MSG_TIME_SYNC. Check that battery.cpp includes i2c_mutex usage.
  </verify>
  <done>
    protocol.h defines MSG_POWER_STATE (0x05), MSG_TIME_SYNC (0x06), PowerStateMsg, and TimeSyncMsg. battery.h/cpp provide battery_init() and battery_read() with I2C mutex protection. platformio.ini includes SparkFun MAX1704x lib_dep for env:display.
  </done>
</task>

<task type="auto">
  <name>Task 2: Power state machine + brightness wrappers</name>
  <files>
    display/power.h
    display/power.cpp
    display/display_hw.h
    display/display_hw.cpp
  </files>
  <action>
1. Add to `display/display_hw.h`:
   ```cpp
   void set_backlight(uint8_t level);   // 0=off, 255=max. Wraps lcd.setBrightness().
   uint8_t get_backlight();
   ```

2. Add to `display/display_hw.cpp` (after the existing code):
   - Static `uint8_t current_brightness = 200;`
   - `set_backlight(uint8_t level)`: Set `current_brightness = level`, call `lcd.setBrightness(level)`.
   - `get_backlight()`: Return `current_brightness`.
   - NOTE: The `lcd` object is already static in display_hw.cpp, so these functions can access it directly.

3. Create `display/power.h`:
   ```cpp
   #pragma once
   #include <cstdint>

   enum PowerState : uint8_t {
       POWER_ACTIVE,   // Full brightness, normal operation
       POWER_DIMMED,   // Reduced brightness, idle timeout
       POWER_CLOCK,    // Minimal brightness, clock mode (PC off)
   };

   void power_init();              // Set initial state to ACTIVE
   void power_update();            // Call from loop() -- checks idle timeout
   void power_activity();          // Call on touch or incoming message -- resets idle timer, wakes from DIMMED
   void power_shutdown_received(); // Call when MSG_POWER_STATE shutdown received -- enter clock mode
   void power_wake_detected();     // Call when any bridge message received in CLOCK_MODE -- return to ACTIVE
   PowerState power_get_state();   // Get current power state

   // Brightness cycling for user control (3 presets: HIGH/MED/LOW)
   void power_cycle_brightness();  // Cycle through brightness presets (only in ACTIVE state)
   ```

4. Create `display/power.cpp`:
   - Include power.h, display_hw.h, Arduino.h
   - Constants:
     - `IDLE_TIMEOUT_MS = 60000` (60 seconds)
     - `BRIGHTNESS_ACTIVE = 200`
     - `BRIGHTNESS_DIMMED = 64`
     - `BRIGHTNESS_CLOCK = 16`
   - Static state: `PowerState current_state = POWER_ACTIVE`, `uint32_t last_activity_ms = 0`
   - Brightness presets for user cycling: `{255, 180, 100}` with index tracking, only applied in ACTIVE state
   - `power_init()`: Set state to ACTIVE, set backlight to BRIGHTNESS_ACTIVE, reset last_activity_ms to millis().
   - `power_update()`: If ACTIVE and idle > IDLE_TIMEOUT_MS, transition to DIMMED (set_backlight(BRIGHTNESS_DIMMED), update state). No action in DIMMED or CLOCK states.
   - `power_activity()`: Reset last_activity_ms. If state is DIMMED, transition to ACTIVE (set_backlight to current user brightness preset, update state). If CLOCK, do nothing (wake only on bridge message via power_wake_detected).
   - `power_shutdown_received()`: Transition to CLOCK_MODE from any state. set_backlight(BRIGHTNESS_CLOCK). Log to Serial.
   - `power_wake_detected()`: If state is CLOCK, transition to ACTIVE. set_backlight(BRIGHTNESS_ACTIVE). Log to Serial.
   - `power_get_state()`: Return current_state.
   - `power_cycle_brightness()`: Only works in ACTIVE state. Cycle through brightness presets array, apply via set_backlight(). Reset idle timer.
  </action>
  <verify>
    `pio run -e display` compiles without errors. Verify power.cpp calls set_backlight() for transitions. Verify display_hw.cpp has set_backlight/get_backlight implementations.
  </verify>
  <done>
    Power state machine (ACTIVE/DIMMED/CLOCK_MODE) implemented with idle timeout, shutdown, and wake transitions. Brightness wrappers (set_backlight/get_backlight) added to display_hw. User brightness cycling via power_cycle_brightness() with 3 presets.
  </done>
</task>

</tasks>

<verification>
- `pio run -e display` compiles cleanly
- `pio run -e bridge` still compiles cleanly (protocol.h changes are backward-compatible additive)
- shared/protocol.h has 6 message types (0x01-0x06) with PowerStateMsg and TimeSyncMsg structs
- display/battery.cpp uses i2c_mutex for all I2C access
- display/power.cpp implements all 3 states with proper transitions
- display/display_hw.cpp has set_backlight() wrapping lcd.setBrightness()
</verification>

<success_criteria>
Both firmware targets compile. Protocol extended. Battery module reads from MAX17048 with graceful "unavailable" fallback. Power state machine handles ACTIVE->DIMMED->CLOCK transitions. Brightness control API available.
</success_criteria>

<output>
After completion, create `.planning/phases/04-battery-management-power-states/04-01-SUMMARY.md`
</output>
