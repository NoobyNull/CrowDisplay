---
phase: 04-battery-management-power-states
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - companion/hotkey_companion.py
autonomous: true

must_haves:
  truths:
    - "Companion app listens for systemd PrepareForShutdown D-Bus signal and sends MSG_POWER_STATE shutdown to bridge before PC powers off"
    - "Companion app sends epoch time with each stats update so display can show accurate clock"
    - "Shutdown signal uses inhibitor lock to delay shutdown until HID message is sent"
    - "All HID writes include a 1-byte message type prefix after report ID (0x03=stats, 0x05=power, 0x06=time) for bridge dispatch"
  artifacts:
    - path: "companion/hotkey_companion.py"
      provides: "D-Bus shutdown listener, time sync in stats packets, inhibitor lock"
      contains: "PrepareForShutdown"
  key_links:
    - from: "companion/hotkey_companion.py"
      to: "shared/protocol.h"
      via: "MSG_POWER_STATE message format (0x05 byte prefix + PowerStateMsg payload)"
      pattern: "0x05"
    - from: "companion/hotkey_companion.py"
      to: "shared/protocol.h"
      via: "MSG_TIME_SYNC message format (0x06 byte prefix + epoch uint32 LE)"
      pattern: "0x06"
---

<objective>
Extend the companion app with D-Bus shutdown signal detection (using dbus-next + inhibitor lock) and time sync messaging, so the display can enter clock mode on PC shutdown and show accurate time.

Purpose: Enable the PC-to-display shutdown signaling chain (COMP-03) and provide the time source needed for clock mode (no onboard RTC on CrowPanel).
Output: Updated companion app that sends MSG_POWER_STATE on shutdown and MSG_TIME_SYNC with each stats update.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@companion/hotkey_companion.py
@shared/protocol.h
@.planning/phases/04-battery-management-power-states/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: D-Bus shutdown listener + time sync</name>
  <files>
    companion/hotkey_companion.py
  </files>
  <action>
Modify `companion/hotkey_companion.py` to add shutdown detection and time sync. All changes are additive to the existing code.

1. **Add imports** at the top:
   ```python
   import threading
   import asyncio
   ```
   Note: `dbus-next` will be imported inside the shutdown listener function to avoid hard dependency (graceful degradation if not installed).

2. **Add MSG_POWER_STATE and MSG_TIME_SYNC constants** near the existing constants:
   ```python
   MSG_POWER_STATE = 0x05
   MSG_TIME_SYNC = 0x06
   POWER_SHUTDOWN = 0
   POWER_WAKE = 1
   ```

3. **Add a `shutdown_event` threading.Event** in the globals section:
   ```python
   shutdown_event = threading.Event()
   ```

4. **Add a `start_dbus_shutdown_listener()` function** that runs in a background thread:
   - Create an asyncio event loop in the thread
   - Connect to system bus via `dbus_next.aio.MessageBus(bus_type=BusType.SYSTEM)`
   - Introspect `org.freedesktop.login1` at path `/org/freedesktop/login1`
   - Get the `org.freedesktop.login1.Manager` interface
   - Call `manager.call_inhibit('shutdown', 'HotkeyCompanion', 'Sending shutdown signal to display bridge', 'delay')` to get inhibitor fd
   - Register signal handler for `PrepareForShutdown`:
     - When `start=True`, set `shutdown_event.set()`, then close the inhibitor fd (`os.close(inhibit_fd)`) to release the lock
   - Run `await bus.wait_for_disconnect()` to keep listening
   - Wrap entire function in try/except to log and gracefully degrade if dbus-next is not installed or system bus is unavailable

5. **Add `send_power_state(device, state)` helper function**:
   - Pack: `b"\x00" + bytes([MSG_POWER_STATE, state])` (report ID 0x00 + msg type + payload)
   - Write to device
   - Log the action

6. **Add `send_time_sync(device)` helper function**:
   - Get current epoch: `int(time.time())`
   - Pack: `b"\x00" + bytes([MSG_TIME_SYNC]) + struct.pack("<I", epoch)`
   - Write to device
   - This is called each stats loop iteration alongside the stats payload

7. **Modify the `main()` function**:
   - After GPU collector init, start the D-Bus listener thread:
     ```python
     dbus_thread = threading.Thread(target=_run_dbus_listener, daemon=True)
     dbus_thread.start()
     ```
     Where `_run_dbus_listener` creates an asyncio loop and runs `start_dbus_shutdown_listener()`.
   - In the main stats loop, after sending stats, also call `send_time_sync(device)` (wrapped in try/except, same error handling as stats write).
   - In the main stats loop, check `shutdown_event.is_set()` at the top of each iteration. If set:
     - Call `send_power_state(device, POWER_SHUTDOWN)`
     - Log "Shutdown signal sent to bridge"
     - Set `running = False` to exit the loop cleanly
     - The inhibitor lock is already released in the D-Bus callback

8. **Important implementation details**:
   - The D-Bus thread must NOT access the HID device directly (thread safety). It only sets `shutdown_event`. The main thread reads the event and sends the HID message.
   - `send_time_sync` uses the same `b"\x00"` report ID prefix as stats writes (hidapi Linux requirement).
   - If `dbus-next` is not installed, log a warning and skip the D-Bus thread entirely. The companion still works for stats streaming.
   - The existing signal handler for SIGINT/SIGTERM should remain unchanged.

9. **CRITICAL: Update existing stats write to include type prefix byte.** The bridge (Plan 03) will switch to a type-prefixed vendor HID protocol where the first payload byte is the message type. ALL companion HID writes must include this prefix. Change the existing stats write from:
   ```python
   device.write(b"\x00" + packed)
   ```
   to:
   ```python
   device.write(b"\x00" + bytes([0x03]) + packed)  # 0x03 = MSG_STATS type prefix
   ```
   This is a coordinated protocol change with the bridge firmware. The `0x03` byte matches MSG_STATS from protocol.h. Similarly, `send_power_state` uses `0x05` (MSG_POWER_STATE) and `send_time_sync` uses `0x06` (MSG_TIME_SYNC) as their first payload byte after the report ID.
  </action>
  <verify>
    `python3 -c "import companion.hotkey_companion"` or `python3 -m py_compile companion/hotkey_companion.py` succeeds without syntax errors. Verify the file contains `PrepareForShutdown`, `MSG_POWER_STATE`, `MSG_TIME_SYNC`, and `shutdown_event`.
  </verify>
  <done>
    Companion app: (1) listens for D-Bus PrepareForShutdown signal via dbus-next in background thread with inhibitor lock, (2) sends MSG_POWER_STATE shutdown to bridge before PC powers off, (3) sends MSG_TIME_SYNC epoch seconds with each stats update cycle. Gracefully degrades if dbus-next is not installed.
  </done>
</task>

</tasks>

<verification>
- `python3 -m py_compile companion/hotkey_companion.py` succeeds
- File contains PrepareForShutdown signal handling
- File contains inhibitor lock (call_inhibit)
- File contains MSG_TIME_SYNC sending in stats loop
- File contains shutdown_event threading.Event coordination
- Existing stats streaming logic is preserved and unchanged
</verification>

<success_criteria>
Companion app compiles cleanly. D-Bus shutdown listener integrated with inhibitor lock. Time sync message sent each stats cycle. Main thread checks shutdown_event and sends MSG_POWER_STATE before exiting. Graceful degradation if dbus-next unavailable.
</success_criteria>

<output>
After completion, create `.planning/phases/04-battery-management-power-states/04-02-SUMMARY.md`
</output>
