---
phase: 04-battery-management-power-states
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - display/ui.h
  - display/ui.cpp
  - display/main.cpp
  - bridge/main.cpp
autonomous: true

must_haves:
  truths:
    - "Stats header title bar shows battery percentage, ESP-NOW link indicator, and tappable brightness control"
    - "Clock mode screen displays time (HH:MM) and battery percentage on a minimal dark background"
    - "Display transitions to clock mode when MSG_POWER_STATE shutdown is received"
    - "Display wakes from clock mode to active when any bridge message is received"
    - "Tapping brightness icon in header cycles through HIGH/MED/LOW presets"
    - "Bridge relays MSG_POWER_STATE and MSG_TIME_SYNC from companion (vendor HID) to display (ESP-NOW)"
    - "Display main loop drives power state machine with idle timeout and activity tracking"
  artifacts:
    - path: "display/ui.h"
      provides: "show_clock_mode(), show_hotkey_view(), update_device_status() declarations"
      contains: "show_clock_mode"
    - path: "display/ui.cpp"
      provides: "Clock screen, device status indicators in header, brightness tap handler"
      contains: "clock_screen"
    - path: "display/main.cpp"
      provides: "Power state machine integration, MSG_POWER_STATE/MSG_TIME_SYNC handling, activity tracking"
      contains: "power_update"
    - path: "bridge/main.cpp"
      provides: "MSG_POWER_STATE and MSG_TIME_SYNC relay from vendor HID to ESP-NOW"
      contains: "MSG_POWER_STATE"
  key_links:
    - from: "display/main.cpp"
      to: "display/power.h"
      via: "power_update() in loop, power_activity() on touch/message"
      pattern: "power_update"
    - from: "display/main.cpp"
      to: "display/ui.h"
      via: "show_clock_mode() on shutdown, show_hotkey_view() on wake"
      pattern: "show_clock_mode"
    - from: "bridge/main.cpp"
      to: "shared/protocol.h"
      via: "MSG_POWER_STATE and MSG_TIME_SYNC dispatch in vendor HID handler"
      pattern: "MSG_POWER_STATE"
    - from: "display/ui.cpp"
      to: "display/battery.h"
      via: "battery_read() for header status display"
      pattern: "battery_read"
---

<objective>
Integrate the power state machine and battery monitoring into the display UI and main loop, add device status indicators to the header bar, create the clock mode screen, and extend the bridge to relay power state and time sync messages from the companion app to the display.

Purpose: Wire everything together so the display shows battery/link/brightness status, transitions between power states, and the bridge serves as the relay for shutdown and time sync signals.
Output: Fully integrated display firmware with power management UI and bridge relay for MSG_POWER_STATE/MSG_TIME_SYNC.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-battery-management-power-states/04-01-SUMMARY.md
@display/ui.h
@display/ui.cpp
@display/main.cpp
@bridge/main.cpp
@display/espnow_link.h
@display/power.h
@display/battery.h
@shared/protocol.h
@.planning/phases/04-battery-management-power-states/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Display UI - device status header + clock screen + brightness control</name>
  <files>
    display/ui.h
    display/ui.cpp
  </files>
  <action>
1. **Update `display/ui.h`** -- add new declarations:
   ```cpp
   // Power state UI transitions
   void show_clock_mode();      // Switch to clock screen (called by power state machine)
   void show_hotkey_view();     // Switch back to main screen (called on wake)

   // Device status update (call from main loop every ~10s or on change)
   void update_device_status(uint8_t battery_pct, bool espnow_linked, uint8_t brightness_level);

   // Update clock display (call in clock mode from main loop)
   void update_clock_time();
   ```

2. **Modify `display/ui.cpp`** -- add device status indicators to the existing header bar and create a clock mode screen. Include new headers: `battery.h`, `power.h`, `<sys/time.h>`.

   **a) Device status in title header bar (DISP-08):**
   - Add static label objects for battery, link, and brightness in the header bar alongside the existing title and status labels.
   - In `create_ui()`, after creating the status_label, add three new elements to the right side of the header bar:
     - Battery label: `"-- %%"` (or `LV_SYMBOL_CHARGE " --%"`) right-aligned, initially showing "--%"
     - Link indicator: `LV_SYMBOL_WIFI` label, colored green when linked, grey when stale
     - Brightness button: `LV_SYMBOL_IMAGE` (sun-like icon) as a clickable label/button. Add event callback that calls `power_cycle_brightness()` from power.h on LV_EVENT_CLICKED.
   - Rearrange header layout: Title on the left, device status indicators (brightness btn, link icon, battery) on the right. Use flex layout or manual alignment. The existing status_label ("Ready" / "Sent: ...") can remain but may need to move or shrink.
   - Store label references as static variables: `static lv_obj_t *batt_label, *link_label, *bright_btn;`

   **b) `update_device_status()` implementation:**
   - Update battery label: If `battery_pct == 0xFF`, show "BAT N/A". Otherwise show "BAT XX%". Color-code: green (>50), yellow (20-50), red (<20).
   - Update link indicator: If `espnow_linked` is true, set color green (0x2ECC71). Otherwise grey (0x7F8C8D).
   - Brightness indicator can just be a static icon (the tap does the cycling).

   **c) Clock mode screen (DISP-09):**
   - Create the clock screen at startup in `create_ui()` using `lv_obj_create(NULL)` -- this creates an independent screen object, NOT added to scr_act yet. CRITICAL: Do NOT use `lv_scr_load()` here, just create and style the screen object.
   - Style: dark background (0x0f0f23), centered large time label using `lv_font_montserrat_48` (or `_46` if 48 unavailable -- check LVGL v8.3.11 built-in fonts, `lv_font_montserrat_48` exists), battery percentage below in `lv_font_montserrat_22`.
   - Store references: `static lv_obj_t *clock_screen, *clock_time_label, *clock_batt_label;`
   - Layout:
     ```
     ┌─────────────────────────────┐
     │                             │
     │         14:32               │  (lv_font_montserrat_48, white)
     │                             │
     │        BAT 85%              │  (lv_font_montserrat_22, grey)
     │                             │
     └─────────────────────────────┘
     ```

   **d) `show_clock_mode()`:**
   - Call `lv_scr_load(clock_screen)` to switch to clock screen.
   - Update clock time immediately via `update_clock_time()`.

   **e) `show_hotkey_view()`:**
   - Call `lv_scr_load(main_screen)` where main_screen is the original screen.
   - IMPORTANT: Save reference to the original screen at the start of `create_ui()`: `static lv_obj_t *main_screen = lv_scr_act();` (before any widgets are added, the default screen IS the main screen, so save it early).

   **f) `update_clock_time()`:**
   - Use `time()` and `localtime()` from `<ctime>` to get current HH:MM.
   - Update clock_time_label: `lv_label_set_text_fmt(clock_time_label, "%02d:%02d", tm->tm_hour, tm->tm_min)`.
   - Update clock_batt_label with current battery_read() result.
   - NOTE: Time accuracy depends on MSG_TIME_SYNC being received from companion. If never synced, will show 00:00 (epoch start). This is acceptable -- clock mode is only meaningful after companion has been running.
  </action>
  <verify>
    `pio run -e display` compiles without errors. Verify ui.cpp creates clock_screen at startup (not dynamically). Verify brightness button has event callback. Verify show_clock_mode/show_hotkey_view use lv_scr_load().
  </verify>
  <done>
    Title header bar shows battery %, ESP-NOW link indicator, and tappable brightness button. Clock screen created at startup with large time and battery display. show_clock_mode() and show_hotkey_view() switch between screens. update_device_status() updates header indicators. update_clock_time() refreshes clock display from system time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Main loop integration + bridge relay</name>
  <files>
    display/main.cpp
    bridge/main.cpp
  </files>
  <action>
1. **Modify `display/main.cpp`** to integrate power state machine, battery monitoring, and new message handling:

   **a) Add includes:** `battery.h`, `power.h`, `<sys/time.h>`

   **b) Add new static timing variables:**
   ```cpp
   static uint32_t battery_timer = 0;
   static uint32_t device_status_timer = 0;
   static uint32_t clock_update_timer = 0;
   static uint32_t last_bridge_msg_time = 0;
   static const uint32_t BRIDGE_LINK_TIMEOUT_MS = 10000;  // 10s to consider link stale
   ```

   **c) In `setup()`:**
   - After `espnow_link_init()` and before `create_ui()`, add:
     ```cpp
     battery_init();  // Try to find MAX17048 (non-fatal if absent)
     ```
   - After `create_ui()`, add:
     ```cpp
     power_init();  // Set initial power state to ACTIVE
     ```

   **d) In `loop()`, restructure to add power state awareness:**

   - **Activity tracking:** After touch_poll(), if touch was detected (check a touch state flag or add touch activity detection), call `power_activity()`. The simplest approach: call `power_activity()` inside the touch polling block whenever a touch read indicates a press. Alternatively, add a `touch_was_pressed()` function in touch.h/cpp that returns true if last poll had a touch. For now, a simpler approach: call `power_activity()` whenever any ESP-NOW message is received (already have that in the message handler).

   - **Power state update:** Call `power_update()` every loop iteration (it's cheap -- just a millis() comparison).

   - **Battery reading (every 15 seconds):**
     ```cpp
     if (millis() - battery_timer >= 15000) {
         battery_timer = millis();
         // battery_read() is called in update_device_status, or read here and pass to UI
     }
     ```

   - **Device status update (every 5 seconds):** Call `update_device_status()` with current battery_read(), ESP-NOW link state (true if last_bridge_msg_time within BRIDGE_LINK_TIMEOUT_MS), and get_backlight().

   - **Message handling expansion:** In the `espnow_poll_msg()` handler, add cases:
     ```cpp
     if (msg_type == MSG_POWER_STATE && msg_len >= sizeof(PowerStateMsg)) {
         PowerStateMsg *ps = (PowerStateMsg *)msg_payload;
         if (ps->state == POWER_SHUTDOWN) {
             power_shutdown_received();
             show_clock_mode();
         }
         // POWER_WAKE is handled implicitly (any bridge message = wake)
     }
     if (msg_type == MSG_TIME_SYNC && msg_len >= sizeof(TimeSyncMsg)) {
         TimeSyncMsg *ts = (TimeSyncMsg *)msg_payload;
         struct timeval tv = { .tv_sec = (time_t)ts->epoch_seconds, .tv_usec = 0 };
         settimeofday(&tv, nullptr);
         Serial.printf("Time synced: %lu\n", ts->epoch_seconds);
     }
     ```

   - **Wake detection:** When ANY message is received from bridge (MSG_STATS, MSG_HOTKEY_ACK, MSG_POWER_STATE with WAKE, MSG_TIME_SYNC), update `last_bridge_msg_time = millis()` and call `power_activity()`. If in CLOCK_MODE and a non-shutdown message arrives, call `power_wake_detected()` and `show_hotkey_view()`.

   - **Clock mode update:** If `power_get_state() == POWER_CLOCK` and millis() - clock_update_timer >= 30000 (every 30s), call `update_clock_time()`.

   - **Touch activity:** In the touch polling section, add a way to detect touch-down. The simplest: read LVGL's indev state or add `power_activity()` call inside the touch_poll block (it resets the idle timer, which is harmless if called too often -- millis() assignment is cheap).

2. **Modify `bridge/main.cpp`** to relay new message types from companion:

   **a) In the vendor HID polling section**, after the existing stats relay block, add handling for MSG_POWER_STATE and MSG_TIME_SYNC. The companion sends these as separate HID reports. The first byte after report ID indicates the message type:

   ```cpp
   // Check message type byte (first byte of vendor report payload)
   if (vendor_len >= 1) {
       uint8_t msg_type = vendor_buf[0];
       if (msg_type == MSG_STATS && vendor_len >= 1 + sizeof(StatsPayload)) {
           espnow_send(MSG_STATS, vendor_buf + 1, sizeof(StatsPayload));
           Serial.println("STATS: relayed to display");
       } else if (msg_type == MSG_POWER_STATE && vendor_len >= 1 + sizeof(PowerStateMsg)) {
           espnow_send(MSG_POWER_STATE, vendor_buf + 1, sizeof(PowerStateMsg));
           Serial.printf("POWER: relayed state=%d to display\n", vendor_buf[1]);
       } else if (msg_type == MSG_TIME_SYNC && vendor_len >= 1 + sizeof(TimeSyncMsg)) {
           espnow_send(MSG_TIME_SYNC, vendor_buf + 1, sizeof(TimeSyncMsg));
           Serial.println("TIME: relayed to display");
       }
   }
   ```

   WAIT -- review the current bridge vendor HID handler. Currently it assumes the entire vendor report IS a StatsPayload (no type prefix). The companion currently sends raw StatsPayload bytes. We need to decide: either (a) add a type prefix to ALL companion messages (breaking change to stats), or (b) use message length to distinguish (fragile).

   **RECOMMENDED: Add a 1-byte message type prefix to all companion HID writes.** This means:
   - Companion stats writes become: `b"\x00" + bytes([MSG_STATS]) + packed_stats` (report ID + type + payload)
   - Companion power writes: `b"\x00" + bytes([MSG_POWER_STATE]) + bytes([state])`
   - Companion time writes: `b"\x00" + bytes([MSG_TIME_SYNC]) + struct.pack("<I", epoch)`

   This requires updating the bridge vendor HID handler to parse the type prefix, AND updating the companion stats write to include the type prefix. The companion changes are in Plan 02. Make the bridge handler work with the type prefix:

   Replace the existing vendor HID block with:
   ```cpp
   if (poll_vendor_hid(vendor_buf, vendor_len)) {
       if (vendor_len >= 1) {
           uint8_t msg_type = vendor_buf[0];
           uint8_t *payload = vendor_buf + 1;
           size_t payload_len = vendor_len - 1;

           switch (msg_type) {
               case MSG_STATS:
                   if (payload_len >= sizeof(StatsPayload)) {
                       espnow_send(MSG_STATS, payload, sizeof(StatsPayload));
                       Serial.println("STATS: relayed to display");
                   }
                   break;
               case MSG_POWER_STATE:
                   if (payload_len >= sizeof(PowerStateMsg)) {
                       espnow_send(MSG_POWER_STATE, payload, sizeof(PowerStateMsg));
                       Serial.printf("POWER: relayed state=%d\n", payload[0]);
                   }
                   break;
               case MSG_TIME_SYNC:
                   if (payload_len >= sizeof(TimeSyncMsg)) {
                       espnow_send(MSG_TIME_SYNC, payload, sizeof(TimeSyncMsg));
                       Serial.println("TIME: relayed to display");
                   }
                   break;
               default:
                   Serial.printf("VENDOR: unknown type 0x%02X len=%zu\n", msg_type, vendor_len);
                   break;
           }
       }
   }
   ```

   **IMPORTANT:** This is a breaking change to the companion-bridge protocol. Plan 02 (companion) must also update the stats write to include the MSG_STATS type prefix byte. Since Plan 02 runs in Wave 1 (parallel), the companion changes will be made there. Both changes must land before testing. The companion stats write changes to: `device.write(b"\x00" + bytes([0x03]) + packed)` where 0x03 = MSG_STATS.

   Actually, re-reading Plan 02 -- the companion `send_time_sync()` and `send_power_state()` already include the type prefix. But the existing stats write does NOT include a type prefix. Plan 02's task description needs to also modify the stats write. Let me ensure that's covered:

   In the companion stats write (Plan 02 should handle this too), change:
   ```python
   device.write(b"\x00" + packed)
   ```
   to:
   ```python
   device.write(b"\x00" + bytes([0x03]) + packed)  # 0x03 = MSG_STATS
   ```

   Since Plan 02 already modifies the companion, this change MUST be included there. Add a note in the bridge code: "Requires companion to send type-prefixed HID reports (MSG_STATS byte before payload)".
  </action>
  <verify>
    `pio run -e display` and `pio run -e bridge` both compile without errors. Verify display/main.cpp calls power_init(), power_update(), handles MSG_POWER_STATE and MSG_TIME_SYNC. Verify bridge/main.cpp parses vendor HID reports with type prefix byte.
  </verify>
  <done>
    Display main loop: integrates power_init/power_update, battery polling (15s), device status updates (5s), MSG_POWER_STATE/MSG_TIME_SYNC handling, wake detection, clock mode updates, touch activity tracking. Bridge: relays MSG_POWER_STATE and MSG_TIME_SYNC from companion vendor HID to display ESP-NOW, with type-prefixed protocol for all companion messages.
  </done>
</task>

</tasks>

<verification>
- `pio run -e display` compiles cleanly
- `pio run -e bridge` compiles cleanly
- display/main.cpp calls power_init(), power_update(), battery_init()
- display/main.cpp handles MSG_POWER_STATE and MSG_TIME_SYNC messages
- display/main.cpp calls show_clock_mode() on shutdown and show_hotkey_view() on wake
- display/ui.cpp creates clock_screen at startup (not dynamically)
- display/ui.cpp has brightness button with event callback
- bridge/main.cpp has type-prefix dispatcher for vendor HID reports (MSG_STATS, MSG_POWER_STATE, MSG_TIME_SYNC)
</verification>

<success_criteria>
Both firmware targets compile. Display shows device status in header (battery, link, brightness). Clock screen exists and can be activated. Power state transitions work in firmware. Bridge relays all three message types from companion to display. Main loop drives the power state machine with activity tracking.
</success_criteria>

<output>
After completion, create `.planning/phases/04-battery-management-power-states/04-03-SUMMARY.md`
</output>
