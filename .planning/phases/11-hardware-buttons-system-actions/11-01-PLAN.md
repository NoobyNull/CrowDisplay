---
phase: 11-hardware-buttons-system-actions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - display/config.h
  - display/config.cpp
  - display/ui.cpp
  - display/ui.h
  - display/power.h
  - display/power.cpp
autonomous: true
requirements:
  - HW-SYS-ACTIONS
  - HW-CONFIG-MODEL

must_haves:
  truths:
    - "ActionType enum includes PAGE_NEXT, PAGE_PREV, PAGE_GOTO, MODE_CYCLE, BRIGHTNESS, CONFIG_MODE"
    - "config.h defines HwButtonConfig, EncoderConfig, ModeCycleConfig, DisplaySettings structs"
    - "AppConfig includes hw_buttons[4], encoder, mode_cycle, and display_settings members"
    - "config_load() deserializes hardware_buttons, encoder, mode_cycle, display_settings from JSON with defaults"
    - "config_save() serializes all new config sections to JSON"
    - "btn_event_cb in ui.cpp handles system action types locally (page nav, mode cycle, brightness)"
    - "mode_cycle_next() cycles through user-configured enabled_modes list"
  artifacts:
    - path: "display/config.h"
      provides: "HwButtonConfig, EncoderConfig, ModeCycleConfig, DisplaySettings structs, extended ActionType enum"
      contains: "ACTION_PAGE_NEXT"
    - path: "display/config.cpp"
      provides: "JSON serialization for hardware config sections"
      contains: "hardware_buttons"
    - path: "display/ui.cpp"
      provides: "System action dispatch in btn_event_cb"
      contains: "ACTION_MODE_CYCLE"
    - path: "display/power.cpp"
      provides: "mode_cycle_next() function"
      contains: "mode_cycle_next"
  key_links:
    - from: "display/ui.cpp"
      to: "display/power.cpp"
      via: "mode_cycle_next() and power_cycle_brightness() calls"
      pattern: "mode_cycle_next|power_cycle_brightness"
    - from: "display/config.cpp"
      to: "display/config.h"
      via: "JSON deser populates HwButtonConfig/EncoderConfig/ModeCycleConfig"
      pattern: "hardware_buttons|encoder|mode_cycle"
---

<objective>
Extend the firmware config model and action system with new system action types and hardware button/encoder configuration structures.

Purpose: Foundation for hardware input support -- defines the data model, action types, and local action dispatch that all subsequent plans build upon.
Output: Extended config.h structs, config.cpp JSON serialization, system action handling in ui.cpp, mode cycling in power.cpp.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-hardware-buttons-system-actions/11-RESEARCH.md

@display/config.h
@display/config.cpp
@display/ui.h
@display/ui.cpp
@display/power.h
@display/power.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend ActionType enum and add hardware config structs to config.h</name>
  <files>display/config.h, display/power.h</files>
  <action>
In display/config.h, add 6 new ActionType enum values after ACTION_DISPLAY_PICTURE:
```
ACTION_PAGE_NEXT = 8,       // Navigate to next page
ACTION_PAGE_PREV = 9,       // Navigate to previous page
ACTION_PAGE_GOTO = 10,      // Go to specific page (uses keycode field as page number)
ACTION_MODE_CYCLE = 11,     // Cycle through configured display modes
ACTION_BRIGHTNESS = 12,     // Cycle brightness presets
ACTION_CONFIG_MODE = 13,    // Enter SoftAP config mode
```

Add new structs after AppConfig declaration area (before the I/O helpers):

```cpp
struct HwButtonConfig {
    ActionType action_type;
    std::string label;
    uint8_t keycode;        // For PAGE_GOTO (page number), or HOTKEY keycode
    uint16_t consumer_code; // For MEDIA_KEY
    uint8_t modifiers;      // For HOTKEY modifiers
    HwButtonConfig() : action_type(ACTION_PAGE_NEXT), label(""), keycode(0),
                       consumer_code(0), modifiers(0) {}
};

struct EncoderConfig {
    ActionType push_action;
    std::string push_label;
    uint8_t push_keycode;
    uint16_t push_consumer_code;
    uint8_t push_modifiers;
    uint8_t encoder_mode;    // 0=page_nav, 1=volume, 2=brightness, 3=app_select, 4=mode_cycle
    EncoderConfig() : push_action(ACTION_BRIGHTNESS), push_label("Brightness"),
                      push_keycode(0), push_consumer_code(0), push_modifiers(0),
                      encoder_mode(0) {}
};

struct ModeCycleConfig {
    std::vector<uint8_t> enabled_modes; // DisplayMode values in rotation order
    ModeCycleConfig() : enabled_modes({0, 1, 2, 3}) {} // All modes by default
};

struct DisplaySettings {
    uint16_t dim_timeout_sec;
    uint16_t sleep_timeout_sec;
    bool wake_on_touch;
    bool clock_24h;
    uint32_t clock_color_theme;
    uint16_t slideshow_interval_sec;
    std::string slideshow_transition;   // "fade", "slide", "none"
    DisplaySettings() : dim_timeout_sec(60), sleep_timeout_sec(300),
                        wake_on_touch(true), clock_24h(true),
                        clock_color_theme(0xFFFFFF), slideshow_interval_sec(30),
                        slideshow_transition("fade") {}
};
```

Add these members to the AppConfig struct:
```cpp
HwButtonConfig hw_buttons[4];
EncoderConfig encoder;
ModeCycleConfig mode_cycle;
DisplaySettings display_settings;
```

In display/power.h, add the mode cycling function declaration:
```cpp
void mode_cycle_next(const std::vector<uint8_t>& enabled_modes);
```
  </action>
  <verify>PlatformIO build compiles: `pio run -e display 2>&1 | tail -5` shows SUCCESS</verify>
  <done>ActionType enum has 6 new system action values; HwButtonConfig, EncoderConfig, ModeCycleConfig, DisplaySettings structs exist; AppConfig has hw_buttons[4], encoder, mode_cycle, display_settings members</done>
</task>

<task type="auto">
  <name>Task 2: Add JSON serialization for hardware config and system action dispatch</name>
  <files>display/config.cpp, display/ui.cpp, display/ui.h, display/power.cpp</files>
  <action>
In display/config.cpp config_load() function, add deserialization for the new config sections AFTER existing config loading. Use the `doc["field"] | default_value` pattern for backward compatibility (old configs without these fields get defaults):

```cpp
// Hardware buttons (optional, defaults if missing)
JsonArray hw_btns = doc["hardware_buttons"];
if (!hw_btns.isNull()) {
    for (int i = 0; i < 4 && i < (int)hw_btns.size(); i++) {
        JsonObject btn = hw_btns[i];
        config.hw_buttons[i].action_type = (ActionType)(btn["action_type"] | 8); // PAGE_NEXT default
        config.hw_buttons[i].label = btn["label"] | "";
        config.hw_buttons[i].keycode = btn["keycode"] | 0;
        config.hw_buttons[i].consumer_code = btn["consumer_code"] | 0;
        config.hw_buttons[i].modifiers = btn["modifiers"] | 0;
    }
}

// Encoder (optional)
JsonObject enc = doc["encoder"];
if (!enc.isNull()) {
    config.encoder.push_action = (ActionType)(enc["push_action"] | 12); // BRIGHTNESS default
    config.encoder.push_label = enc["push_label"] | "Brightness";
    config.encoder.push_keycode = enc["push_keycode"] | 0;
    config.encoder.push_consumer_code = enc["push_consumer_code"] | 0;
    config.encoder.push_modifiers = enc["push_modifiers"] | 0;
    config.encoder.encoder_mode = enc["encoder_mode"] | 0; // page_nav default
}

// Mode cycle (optional)
JsonArray modes = doc["mode_cycle"];
if (!modes.isNull()) {
    config.mode_cycle.enabled_modes.clear();
    for (JsonVariant m : modes) {
        config.mode_cycle.enabled_modes.push_back(m.as<uint8_t>());
    }
}

// Display settings (optional)
JsonObject ds = doc["display_settings"];
if (!ds.isNull()) {
    config.display_settings.dim_timeout_sec = ds["dim_timeout_sec"] | 60;
    config.display_settings.sleep_timeout_sec = ds["sleep_timeout_sec"] | 300;
    config.display_settings.wake_on_touch = ds["wake_on_touch"] | true;
    config.display_settings.clock_24h = ds["clock_24h"] | true;
    config.display_settings.clock_color_theme = ds["clock_color_theme"] | 0xFFFFFF;
    config.display_settings.slideshow_interval_sec = ds["slideshow_interval_sec"] | 30;
    config.display_settings.slideshow_transition = ds["slideshow_transition"] | "fade";
}
```

In config_save(), add serialization for all new sections after existing config writing:

```cpp
// Hardware buttons
JsonArray hw_btns = doc["hardware_buttons"].to<JsonArray>();
for (int i = 0; i < 4; i++) {
    JsonObject btn = hw_btns.add<JsonObject>();
    btn["action_type"] = (uint8_t)config.hw_buttons[i].action_type;
    btn["label"] = config.hw_buttons[i].label;
    btn["keycode"] = config.hw_buttons[i].keycode;
    btn["consumer_code"] = config.hw_buttons[i].consumer_code;
    btn["modifiers"] = config.hw_buttons[i].modifiers;
}

// Encoder
JsonObject enc = doc["encoder"].to<JsonObject>();
enc["push_action"] = (uint8_t)config.encoder.push_action;
enc["push_label"] = config.encoder.push_label;
enc["push_keycode"] = config.encoder.push_keycode;
enc["push_consumer_code"] = config.encoder.push_consumer_code;
enc["push_modifiers"] = config.encoder.push_modifiers;
enc["encoder_mode"] = config.encoder.encoder_mode;

// Mode cycle
JsonArray modes = doc["mode_cycle"].to<JsonArray>();
for (uint8_t m : config.mode_cycle.enabled_modes) {
    modes.add(m);
}

// Display settings
JsonObject ds = doc["display_settings"].to<JsonObject>();
ds["dim_timeout_sec"] = config.display_settings.dim_timeout_sec;
ds["sleep_timeout_sec"] = config.display_settings.sleep_timeout_sec;
ds["wake_on_touch"] = config.display_settings.wake_on_touch;
ds["clock_24h"] = config.display_settings.clock_24h;
ds["clock_color_theme"] = config.display_settings.clock_color_theme;
ds["slideshow_interval_sec"] = config.display_settings.slideshow_interval_sec;
ds["slideshow_transition"] = config.display_settings.slideshow_transition;
```

In display/ui.cpp, find the btn_event_cb function (the LVGL button event handler). Add cases for the new system action types. These execute LOCALLY on the display -- they do NOT send messages to the bridge/PC:

```cpp
case ACTION_PAGE_NEXT:
    ui_next_page();
    return;
case ACTION_PAGE_PREV:
    ui_prev_page();
    return;
case ACTION_PAGE_GOTO:
    show_page(bed->keycode);  // keycode holds page index
    return;
case ACTION_MODE_CYCLE:
    mode_cycle_next(get_global_config().mode_cycle.enabled_modes);
    return;
case ACTION_BRIGHTNESS:
    power_cycle_brightness();
    return;
case ACTION_CONFIG_MODE:
    // Same behavior as ACTION_DISPLAY_SETTINGS
    show_config_screen();
    config_server_start();
    return;
```

Add a `show_page(int page_index)` function to ui.cpp and declare it in ui.h. It should validate the page_index is within range, then switch to that page (similar to how ui_next_page/ui_prev_page work but jumping to a specific index).

In display/power.cpp, implement mode_cycle_next():
```cpp
void mode_cycle_next(const std::vector<uint8_t>& enabled_modes) {
    if (enabled_modes.empty()) return;
    DisplayMode current = display_get_mode();
    // Find current mode in the enabled list
    int idx = -1;
    for (int i = 0; i < (int)enabled_modes.size(); i++) {
        if (enabled_modes[i] == (uint8_t)current) {
            idx = i;
            break;
        }
    }
    // Advance to next in list (wrap around)
    int next_idx = (idx + 1) % (int)enabled_modes.size();
    display_set_mode((DisplayMode)enabled_modes[next_idx]);
}
```

Note: Include `<vector>` in power.h if not already included. Add `#include "config.h"` or forward-declare as needed.
  </action>
  <verify>PlatformIO build compiles: `pio run -e display 2>&1 | tail -5` shows SUCCESS</verify>
  <done>config_load() reads hardware_buttons/encoder/mode_cycle/display_settings from JSON with defaults; config_save() writes them; btn_event_cb handles ACTION_PAGE_NEXT through ACTION_CONFIG_MODE; mode_cycle_next() cycles through enabled modes; show_page() jumps to specific page</done>
</task>

</tasks>

<verification>
- `pio run -e display` compiles without errors
- Config JSON with hardware_buttons, encoder, mode_cycle, display_settings sections can be loaded
- Config JSON without these sections loads with sensible defaults (backward compatible)
- New ActionType values don't conflict with existing ones
</verification>

<success_criteria>
- ActionType enum extended with 6 system action types (values 8-13)
- 4 new config structs defined with sensible defaults
- AppConfig has hw_buttons[4], encoder, mode_cycle, display_settings members
- JSON round-trip works (load + save preserves all new fields)
- System actions dispatch locally in btn_event_cb without sending to bridge
- mode_cycle_next() cycles through user-configured mode list
</success_criteria>

<output>
After completion, create `.planning/phases/11-hardware-buttons-system-actions/11-01-SUMMARY.md`
</output>
