---
phase: 11-hardware-buttons-system-actions
plan: 03
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - companion/config_manager.py
  - companion/action_executor.py
  - companion/ui/editor_main.py
autonomous: true
requirements:
  - HW-COMPANION-CONFIG
  - HW-EDITOR-HARDWARE

must_haves:
  truths:
    - "config_manager.py defines ACTION_PAGE_NEXT through ACTION_CONFIG_MODE constants (values 8-13)"
    - "VALID_ACTION_TYPES includes all 14 action types (0-13)"
    - "config_manager produces hardware_buttons, encoder, mode_cycle, display_settings in JSON output"
    - "Hardware buttons and encoder appear below the 800x480 canvas area in the editor"
    - "Clicking a hardware button opens the properties panel with all action types including system actions"
    - "Encoder widget shows push action + CW/CCW mode assignment in properties panel"
    - "action_executor ignores system action types (display-local, no PC execution needed)"
  artifacts:
    - path: "companion/config_manager.py"
      provides: "System action type constants, hardware config model, encoder config, mode cycle, display settings"
      contains: "ACTION_PAGE_NEXT"
    - path: "companion/action_executor.py"
      provides: "Graceful skip of display-local system actions"
      contains: "ACTION_PAGE_NEXT"
    - path: "companion/ui/editor_main.py"
      provides: "Hardware button/encoder section below canvas, properties panel integration"
      contains: "HardwareSection"
  key_links:
    - from: "companion/ui/editor_main.py"
      to: "companion/config_manager.py"
      via: "Hardware button config read/write through config dict"
      pattern: "hardware_buttons|encoder"
    - from: "companion/action_executor.py"
      to: "companion/config_manager.py"
      via: "ACTION_PAGE_NEXT and other system action constants"
      pattern: "ACTION_PAGE_NEXT|ACTION_MODE_CYCLE"
---

<objective>
Extend the companion app config model with system action types and hardware button/encoder configuration, and add the hardware input section below the canvas in the editor.

Purpose: Users can configure what each hardware button and encoder action does using the same properties panel as touchscreen widgets.
Output: Updated config_manager.py with full action types, hardware editor section in editor_main.py.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-hardware-buttons-system-actions/11-RESEARCH.md
@.planning/phases/11-hardware-buttons-system-actions/11-01-SUMMARY.md

@companion/config_manager.py
@companion/action_executor.py
@companion/ui/editor_main.py
@companion/ui/button_editor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add system action types and hardware config model to config_manager.py</name>
  <files>companion/config_manager.py, companion/action_executor.py</files>
  <action>
In companion/config_manager.py, add the 6 new action type constants after ACTION_DISPLAY_PICTURE:
```python
ACTION_PAGE_NEXT = 8          # Navigate to next page (display-local)
ACTION_PAGE_PREV = 9          # Navigate to previous page (display-local)
ACTION_PAGE_GOTO = 10         # Go to specific page N (display-local)
ACTION_MODE_CYCLE = 11        # Cycle through configured display modes (display-local)
ACTION_BRIGHTNESS = 12        # Cycle brightness presets (display-local)
ACTION_CONFIG_MODE = 13       # Enter SoftAP config mode (display-local)
```

Update VALID_ACTION_TYPES to include all 14 types:
```python
VALID_ACTION_TYPES = (
    ACTION_HOTKEY, ACTION_MEDIA_KEY, ACTION_LAUNCH_APP, ACTION_SHELL_CMD, ACTION_OPEN_URL,
    ACTION_DISPLAY_SETTINGS, ACTION_DISPLAY_CLOCK, ACTION_DISPLAY_PICTURE,
    ACTION_PAGE_NEXT, ACTION_PAGE_PREV, ACTION_PAGE_GOTO,
    ACTION_MODE_CYCLE, ACTION_BRIGHTNESS, ACTION_CONFIG_MODE,
)
```

Add a set of display-local action types that the companion should NOT try to execute:
```python
DISPLAY_LOCAL_ACTIONS = {
    ACTION_DISPLAY_SETTINGS, ACTION_DISPLAY_CLOCK, ACTION_DISPLAY_PICTURE,
    ACTION_PAGE_NEXT, ACTION_PAGE_PREV, ACTION_PAGE_GOTO,
    ACTION_MODE_CYCLE, ACTION_BRIGHTNESS, ACTION_CONFIG_MODE,
}
```

Add ACTION_TYPE_NAMES dict for the UI dropdown:
```python
ACTION_TYPE_NAMES = {
    ACTION_HOTKEY: "Keyboard Shortcut",
    ACTION_MEDIA_KEY: "Media Key",
    ACTION_LAUNCH_APP: "Launch App",
    ACTION_SHELL_CMD: "Shell Command",
    ACTION_OPEN_URL: "Open URL",
    ACTION_DISPLAY_SETTINGS: "Config Mode",
    ACTION_DISPLAY_CLOCK: "Clock Mode",
    ACTION_DISPLAY_PICTURE: "Picture Frame",
    ACTION_PAGE_NEXT: "Next Page",
    ACTION_PAGE_PREV: "Previous Page",
    ACTION_PAGE_GOTO: "Go to Page",
    ACTION_MODE_CYCLE: "Cycle Mode",
    ACTION_BRIGHTNESS: "Brightness",
    ACTION_CONFIG_MODE: "Config Mode (SoftAP)",
}
```

Add encoder mode names:
```python
ENCODER_MODE_NAMES = {
    0: "Page Navigation",
    1: "Volume Control",
    2: "Brightness",
    3: "App Select",
    4: "Mode Cycle",
}
```

In the config save/load functions, ensure the following JSON sections are preserved/generated:
- `hardware_buttons`: array of 4 objects with action_type, label, keycode, consumer_code, modifiers
- `encoder`: object with push_action, push_label, push_keycode, push_consumer_code, push_modifiers, encoder_mode
- `mode_cycle`: array of uint8 DisplayMode values
- `display_settings`: object with dim_timeout_sec, sleep_timeout_sec, wake_on_touch, clock_24h, clock_color_theme, slideshow_interval_sec, slideshow_transition

Add helper functions:
```python
def get_default_hardware_buttons():
    return [
        {"action_type": ACTION_PAGE_NEXT, "label": "Next Page", "keycode": 0, "consumer_code": 0, "modifiers": 0},
        {"action_type": ACTION_PAGE_PREV, "label": "Prev Page", "keycode": 0, "consumer_code": 0, "modifiers": 0},
        {"action_type": ACTION_MODE_CYCLE, "label": "Mode", "keycode": 0, "consumer_code": 0, "modifiers": 0},
        {"action_type": ACTION_CONFIG_MODE, "label": "Config", "keycode": 0, "consumer_code": 0, "modifiers": 0},
    ]

def get_default_encoder():
    return {
        "push_action": ACTION_BRIGHTNESS, "push_label": "Brightness",
        "push_keycode": 0, "push_consumer_code": 0, "push_modifiers": 0,
        "encoder_mode": 0,
    }

def get_default_mode_cycle():
    return [0, 1, 2, 3]  # All modes enabled

def get_default_display_settings():
    return {
        "dim_timeout_sec": 60, "sleep_timeout_sec": 300,
        "wake_on_touch": True, "clock_24h": True,
        "clock_color_theme": 0xFFFFFF, "slideshow_interval_sec": 30,
        "slideshow_transition": "fade",
    }
```

Ensure config_load (or the ConfigManager class's load method) populates these sections with defaults if missing from JSON, and config_save writes them.

In companion/action_executor.py:
- Import the new action type constants: ACTION_PAGE_NEXT, ACTION_PAGE_PREV, ACTION_PAGE_GOTO, ACTION_MODE_CYCLE, ACTION_BRIGHTNESS, ACTION_CONFIG_MODE, and DISPLAY_LOCAL_ACTIONS
- In the execute function, add an early return for display-local actions:
```python
if action_type in DISPLAY_LOCAL_ACTIONS:
    logger.debug(f"Skipping display-local action type {action_type}")
    return
```
This goes BEFORE the existing action type dispatch switch.
  </action>
  <verify>Run `python -c "from companion.config_manager import ACTION_PAGE_NEXT, VALID_ACTION_TYPES, DISPLAY_LOCAL_ACTIONS; print(len(VALID_ACTION_TYPES), ACTION_PAGE_NEXT)"` should print "14 8"</verify>
  <done>14 action types defined; VALID_ACTION_TYPES includes all; DISPLAY_LOCAL_ACTIONS filters system actions in executor; hardware config defaults and helpers exist; config round-trip preserves hardware sections</done>
</task>

<task type="auto">
  <name>Task 2: Add hardware button/encoder section below canvas in editor</name>
  <files>companion/ui/editor_main.py</files>
  <action>
In companion/ui/editor_main.py, add a hardware input section below the 800x480 canvas area. This section simulates the physical button/encoder layout on the device bezel.

Create a HardwareSection class (can be a QWidget subclass or built inline):

1. **Layout:** Horizontal strip approximately 80px tall, positioned below the canvas in the editor's central area. Use a QHBoxLayout containing:
   - 4 QPushButton widgets labeled "B1", "B2", "B3", "B4" styled as dark gray rectangles (~120x60px each)
   - 1 circular-styled QPushButton for the encoder labeled "ENC" with a rotation indicator (~80x80px)
   - Spacing between buttons to simulate physical bezel layout

2. **Styling:** Use a muted dark gray color scheme (background #2a2a2a, border #555, text #aaa) to visually distinguish from the live display canvas area. Add a subtle header label "Hardware Inputs" above the strip.

3. **Click behavior:** When any hardware button (B1-B4) is clicked:
   - Set the "selected hardware input" state
   - Open/update the properties panel on the right side
   - The properties panel shows:
     - Input name (read-only: "Button 1", "Button 2", etc.)
     - Action Type dropdown (all 14 action types from ACTION_TYPE_NAMES)
     - Label text field
     - Conditional fields based on action_type (same as touchscreen widget properties):
       - ACTION_HOTKEY: keyboard recorder + modifier checkboxes
       - ACTION_MEDIA_KEY: media key dropdown
       - ACTION_LAUNCH_APP: app picker
       - ACTION_SHELL_CMD: command text field
       - ACTION_OPEN_URL: URL text field
       - ACTION_PAGE_GOTO: page number spinner
       - Others: no extra fields needed (action is self-contained)
   - Changes write directly to config dict under `hardware_buttons[i]`

4. **Encoder click behavior:** When the encoder widget is clicked:
   - Show properties panel with:
     - "Encoder Push Action" section: same action type dropdown + fields as buttons, writing to config `encoder.push_action`, `encoder.push_label`, etc.
     - "Encoder Rotation Mode" section: dropdown with ENCODER_MODE_NAMES options, writing to config `encoder.encoder_mode`
   - CW/CCW behavior is determined by the mode (e.g., page_nav = CW:next/CCW:prev), shown as informational text below the dropdown

5. **Properties panel reuse:** The existing properties panel (from button_editor.py or the widget properties in editor_main.py) should be reused. The key is that when a hardware input is selected, the properties panel shows the relevant fields. When a canvas widget is selected, the properties panel shows widget fields. Use a flag or selection state to track which is active.

6. **Config integration:** On editor load, populate the hardware section from `config.get("hardware_buttons", get_default_hardware_buttons())` and `config.get("encoder", get_default_encoder())`. On any property change, update the config dict and mark as dirty.

Use NoScrollComboBox (from companion/ui/no_scroll_combo.py) for all dropdowns per Phase 10 decision.

Import the new constants from config_manager: ACTION_TYPE_NAMES, ENCODER_MODE_NAMES, get_default_hardware_buttons, get_default_encoder, DISPLAY_LOCAL_ACTIONS.
  </action>
  <verify>Run the editor with `python -m companion.crowpanel_editor` -- hardware section should appear below canvas. Clicking B1-B4 or ENC should show properties panel. No crashes on startup.</verify>
  <done>Hardware buttons B1-B4 and encoder ENC appear below 800x480 canvas in dark gray strip; clicking opens properties panel with action type dropdown (14 types); encoder shows push action + rotation mode; changes persist to config dict</done>
</task>

</tasks>

<verification>
- `python -c "from companion.config_manager import VALID_ACTION_TYPES; assert len(VALID_ACTION_TYPES) == 14"` passes
- Editor launches without errors
- Hardware section visible below canvas
- Clicking hardware buttons shows properties panel
- Config save/load preserves hardware_buttons, encoder, mode_cycle, display_settings
</verification>

<success_criteria>
- 14 action types in companion (matching firmware)
- DISPLAY_LOCAL_ACTIONS set prevents companion from executing system actions
- Hardware buttons and encoder configurable in editor with same action type dropdown as widgets
- Encoder properties panel shows push action + rotation mode
- Config JSON round-trips hardware sections correctly
</success_criteria>

<output>
After completion, create `.planning/phases/11-hardware-buttons-system-actions/11-03-SUMMARY.md`
</output>
