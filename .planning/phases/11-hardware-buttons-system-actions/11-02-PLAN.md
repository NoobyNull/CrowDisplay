---
phase: 11-hardware-buttons-system-actions
plan: 02
type: execute
wave: 2
depends_on: ["11-01"]
files_modified:
  - display/hw_input.h
  - display/hw_input.cpp
  - display/main.cpp
  - display/rotary_encoder.h
  - display/rotary_encoder.cpp
  - display/config_server.cpp
  - display/sdcard.h
  - display/sdcard.cpp
autonomous: true
requirements:
  - HW-PCF8575-DRIVER
  - HW-ENCODER-QUAD
  - HW-SD-API
  - HW-APP-SELECT

must_haves:
  truths:
    - "PCF8575 is read via TCA9548A mux channel 0 with I2C mutex protection"
    - "4 hardware buttons are debounced and dispatch configured actions"
    - "Rotary encoder uses quadrature state machine for CW/CCW detection"
    - "Encoder rotation dispatches configured action (page nav, volume, brightness, mode cycle, or app select)"
    - "App-select encoder mode cycles focus through widgets on current page and push fires focused widget"
    - "GET /api/sd/usage returns total_mb, used_mb, free_mb"
    - "GET /api/sd/list?path=/ returns directory listing with file names, sizes, and dir flag"
    - "POST /api/sd/delete with JSON body removes file from SD card"
    - "Old rotary_encoder module is completely replaced"
  artifacts:
    - path: "display/hw_input.h"
      provides: "PCF8575 polling API, button/encoder event dispatch"
      contains: "hw_input_init"
    - path: "display/hw_input.cpp"
      provides: "PCF8575 I2C read, quadrature decoder, debounce, action dispatch"
      contains: "pcf8575_read"
    - path: "display/config_server.cpp"
      provides: "SD card management HTTP endpoints"
      contains: "api/sd/usage"
    - path: "display/sdcard.cpp"
      provides: "Directory listing and usage stats helpers"
      contains: "sdcard_list_dir"
  key_links:
    - from: "display/hw_input.cpp"
      to: "display/touch.h"
      via: "i2c_take()/i2c_give() mutex for bus contention"
      pattern: "i2c_take|i2c_give"
    - from: "display/main.cpp"
      to: "display/hw_input.h"
      via: "hw_input_poll() called every 50ms in loop()"
      pattern: "hw_input_poll"
    - from: "display/hw_input.cpp"
      to: "display/ui.h"
      via: "btn_event_cb dispatch for hardware button actions"
      pattern: "ui_next_page|ui_prev_page|show_page"
---

<objective>
Implement the PCF8575 hardware input driver with quadrature encoder decoding, wire it into the main loop replacing the old rotary_encoder module, and add SD card management HTTP endpoints.

Purpose: Physical hardware buttons and encoder become functional; SD card is manageable remotely via companion.
Output: hw_input module, updated main.cpp, SD card HTTP API in config_server.cpp.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-hardware-buttons-system-actions/11-RESEARCH.md
@.planning/phases/11-hardware-buttons-system-actions/11-01-SUMMARY.md

@display/main.cpp
@display/touch.h
@display/touch.cpp
@display/rotary_encoder.h
@display/rotary_encoder.cpp
@display/config_server.h
@display/config_server.cpp
@display/sdcard.h
@display/sdcard.cpp
@display/ui.h
@display/config.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hw_input module and replace rotary_encoder</name>
  <files>display/hw_input.h, display/hw_input.cpp, display/main.cpp, display/rotary_encoder.h, display/rotary_encoder.cpp</files>
  <action>
Create display/hw_input.h with these declarations:
```cpp
#pragma once
#include <stdint.h>

// Initialize PCF8575 hardware input: scan TCA9548A channel 0 for PCF8575 at 0x20-0x27
// Returns true if PCF8575 found, false if not (hardware buttons disabled gracefully)
bool hw_input_init();

// Poll hardware buttons and encoder. Call every 50ms from loop().
// Reads PCF8575 via I2C mux, debounces buttons, decodes encoder quadrature.
// Dispatches configured actions for button presses and encoder events.
// Requires AppConfig pointer for action mappings.
void hw_input_poll();

// Check if PCF8575 was detected at init
bool hw_input_available();

// Focus management for app-select encoder mode
void hw_input_focus_next();    // Highlight next widget on current page
void hw_input_focus_prev();    // Highlight previous widget
void hw_input_activate_focus(); // Fire the focused widget's action
void hw_input_clear_focus();   // Remove focus highlight (call on page change)
```

Create display/hw_input.cpp implementing:

1. **TCA9548A mux selection + PCF8575 auto-detect at init:**
   - `#define TCA9548A_ADDR 0x70` and `#define PCF8575_MUX_CH 0`
   - At init, wrap in i2c_take()/i2c_give() from touch.h
   - Select mux channel 0: `Wire.beginTransmission(TCA9548A_ADDR); Wire.write(1 << PCF8575_MUX_CH); Wire.endTransmission();`
   - Scan 0x20-0x27 for PCF8575: `Wire.beginTransmission(addr); if (Wire.endTransmission() == 0)` = found
   - Store detected address in static variable. Deselect mux after scan (`Wire.write(0)`)
   - Log found address or "PCF8575 not found" and return false

2. **PCF8575 16-bit read function:**
   - Must hold i2c_take() for the ENTIRE sequence: mux select + PCF8575 read + mux deselect
   - Read 2 bytes: lo = Wire.read(), hi = Wire.read(), return (hi << 8) | lo
   - Deselect mux after read: `Wire.beginTransmission(TCA9548A_ADDR); Wire.write(0); Wire.endTransmission();`
   - Return 0xFFFF on any I2C error (all high = nothing pressed)

3. **Button debounce (per user decision: single press only, no long-press):**
   - Pin masks: BTN1=P1(1<<1), BTN2=P2(1<<2), BTN3=P3(1<<3), BTN4=P4(1<<4), ENC_SW=P0(1<<0)
   - Track previous pin state and last change time per input
   - 50ms debounce window: ignore transitions within 50ms of last valid transition
   - Active LOW: pressed when bit is 0. Fire action on press edge only (was high, now low)

4. **Quadrature encoder state machine:**
   - CLK=P11(1<<11), DT=P10(1<<10)
   - Gray code transition table (see research doc Pattern 3)
   - 80ms minimum interval between valid rotation events for mechanical debounce
   - Return +1 for CW, -1 for CCW, 0 for no change

5. **Action dispatch in hw_input_poll():**
   - Access global config via `get_global_config()` (declared in ui.h)
   - For button presses: get HwButtonConfig from config.hw_buttons[i], dispatch based on action_type:
     - ACTION_HOTKEY/ACTION_MEDIA_KEY: send via espnow (reuse the existing hotkey/media send path)
     - ACTION_LAUNCH_APP/ACTION_SHELL_CMD/ACTION_OPEN_URL: send MSG_BUTTON_PRESS via espnow (companion handles)
     - ACTION_PAGE_NEXT: ui_next_page()
     - ACTION_PAGE_PREV: ui_prev_page()
     - ACTION_PAGE_GOTO: show_page(config.hw_buttons[i].keycode)
     - ACTION_MODE_CYCLE: mode_cycle_next(config.mode_cycle.enabled_modes)
     - ACTION_BRIGHTNESS: power_cycle_brightness()
     - ACTION_CONFIG_MODE: show_config_screen(); config_server_start()
     - ACTION_DISPLAY_SETTINGS/CLOCK/PICTURE: same as existing
   - For encoder push: dispatch config.encoder.push_action the same way
   - For encoder rotation: dispatch based on config.encoder.encoder_mode:
     - 0 (page_nav): CW=ui_next_page(), CCW=ui_prev_page()
     - 1 (volume): CW=send media vol+, CCW=send media vol-
     - 2 (brightness): CW/CCW=power_cycle_brightness()
     - 3 (app_select): CW=hw_input_focus_next(), CCW=hw_input_focus_prev()
     - 4 (mode_cycle): CW=mode_cycle_next(), CCW=mode_cycle_prev (just reverse)
   - Always call power_activity() on any valid input event

6. **App-select focus management:**
   - Static `focused_widget_idx` (-1 = no focus)
   - hw_input_focus_next(): increment focused_widget_idx mod widget_count, apply visual highlight via LVGL border style (e.g., 3px gold border on the focused widget's LVGL object)
   - hw_input_focus_prev(): decrement with wrap
   - hw_input_activate_focus(): if focused_widget_idx >= 0, simulate the focused widget's button press by looking up its WidgetConfig and dispatching its action_type (same dispatch logic as btn_event_cb)
   - hw_input_clear_focus(): reset focused_widget_idx to -1, remove highlight from all widgets
   - To access LVGL widget objects, use the page_containers/widget arrays that ui.cpp manages. Add a `lv_obj_t* ui_get_widget_obj(int page, int widget_idx)` helper to ui.h/ui.cpp that returns the LVGL object for a given widget.

In display/main.cpp:
- Replace `#include "rotary_encoder.h"` with `#include "hw_input.h"`
- In setup(): replace `encoder_init()` with `hw_input_init()` (if it exists)
- In loop(): replace the entire encoder polling block (lines ~187-214, the `if (millis() - encoder_timer >= 50)` block) with:
```cpp
if (millis() - encoder_timer >= 50) {
    encoder_timer = millis();
    hw_input_poll();
}
```
- Remove the `last_encoder_pos` and `encoder_pressed` static variables (no longer needed)

Clear the old rotary_encoder files: empty out rotary_encoder.h and rotary_encoder.cpp (keep files but make them empty stubs with a comment: `// Replaced by hw_input.h/cpp in Phase 11`) so the build doesn't break if anything references them. Actually, better: just delete their content and remove any includes. If the build system picks them up automatically, keeping empty files is fine.
  </action>
  <verify>PlatformIO build compiles: `pio run -e display 2>&1 | tail -5` shows SUCCESS. Check serial log shows PCF8575 detection attempt at startup.</verify>
  <done>hw_input module reads PCF8575 via TCA9548A mux with I2C mutex; 4 buttons debounced with 50ms window; quadrature encoder decoded with 80ms guard; actions dispatched from config; app-select mode cycles widget focus; old rotary_encoder replaced; main.cpp calls hw_input_poll() every 50ms</done>
</task>

<task type="auto">
  <name>Task 2: Add SD card management HTTP endpoints and directory listing helper</name>
  <files>display/config_server.cpp, display/sdcard.h, display/sdcard.cpp</files>
  <action>
In display/sdcard.h, add two new function declarations:
```cpp
// List files in a directory. Calls callback for each entry.
// Returns number of entries, or -1 on error.
typedef void (*sdcard_dir_callback_t)(const char* name, size_t size, bool is_dir, void* user_data);
int sdcard_list_dir(const char* path, sdcard_dir_callback_t cb, void* user_data);

// Get SD card usage stats. Returns total and used in bytes.
bool sdcard_get_usage(uint64_t* total_bytes, uint64_t* used_bytes);
```

In display/sdcard.cpp, implement:
```cpp
int sdcard_list_dir(const char* path, sdcard_dir_callback_t cb, void* user_data) {
    if (!sdcard_mounted()) return -1;
    File dir = SD.open(path);
    if (!dir || !dir.isDirectory()) return -1;
    int count = 0;
    File entry;
    while ((entry = dir.openNextFile())) {
        if (cb) cb(entry.name(), entry.size(), entry.isDirectory(), user_data);
        count++;
        entry.close();
    }
    dir.close();
    return count;
}

bool sdcard_get_usage(uint64_t* total_bytes, uint64_t* used_bytes) {
    if (!sdcard_mounted()) return false;
    *total_bytes = SD.totalBytes();
    *used_bytes = SD.usedBytes();
    return true;
}
```

In display/config_server.cpp, add 3 new HTTP endpoint handlers and register them in the server setup function (where existing routes like `/api/config/upload` are registered):

1. **GET /api/sd/usage:**
```cpp
static void handle_sd_usage() {
    last_activity_time = millis();
    uint64_t total, used;
    if (!sdcard_get_usage(&total, &used)) {
        web_server->send(503, "application/json", "{\"error\":\"SD not mounted\"}");
        return;
    }
    uint32_t total_mb = (uint32_t)(total / (1024 * 1024));
    uint32_t used_mb = (uint32_t)(used / (1024 * 1024));
    uint32_t free_mb = total_mb > used_mb ? total_mb - used_mb : 0;
    String json = "{\"total_mb\":" + String(total_mb) +
                  ",\"used_mb\":" + String(used_mb) +
                  ",\"free_mb\":" + String(free_mb) + "}";
    web_server->send(200, "application/json", json);
}
```

2. **GET /api/sd/list?path=/:**
```cpp
struct ListContext { String json; bool first; };

static void list_entry_cb(const char* name, size_t size, bool is_dir, void* user_data) {
    ListContext* ctx = (ListContext*)user_data;
    if (!ctx->first) ctx->json += ",";
    ctx->first = false;
    ctx->json += "{\"name\":\"" + String(name) + "\"";
    ctx->json += ",\"size\":" + String((uint32_t)size);
    ctx->json += ",\"dir\":" + String(is_dir ? "true" : "false") + "}";
}

static void handle_sd_list() {
    last_activity_time = millis();
    if (!sdcard_mounted()) {
        web_server->send(503, "application/json", "{\"error\":\"SD not mounted\"}");
        return;
    }
    String path = web_server->hasArg("path") ? web_server->arg("path") : "/";
    ListContext ctx;
    ctx.json = "{\"path\":\"" + path + "\",\"files\":[";
    ctx.first = true;
    int count = sdcard_list_dir(path.c_str(), list_entry_cb, &ctx);
    if (count < 0) {
        web_server->send(404, "application/json", "{\"error\":\"Not a directory\"}");
        return;
    }
    ctx.json += "]}";
    web_server->send(200, "application/json", ctx.json);
}
```

3. **POST /api/sd/delete (JSON body: {"path": "/slideshow/img.png"}):**
```cpp
static void handle_sd_delete() {
    last_activity_time = millis();
    if (!sdcard_mounted()) {
        web_server->send(503, "application/json", "{\"error\":\"SD not mounted\"}");
        return;
    }
    // Parse JSON body
    String body = web_server->arg("plain");
    // Simple JSON parsing for "path" field
    int idx = body.indexOf("\"path\"");
    if (idx < 0) {
        web_server->send(400, "application/json", "{\"error\":\"Missing path field\"}");
        return;
    }
    // Use ArduinoJson for proper parsing
    JsonDocument doc;
    DeserializationError err = deserializeJson(doc, body);
    if (err) {
        web_server->send(400, "application/json", "{\"error\":\"Invalid JSON\"}");
        return;
    }
    const char* path = doc["path"];
    if (!path || strlen(path) == 0) {
        web_server->send(400, "application/json", "{\"error\":\"Empty path\"}");
        return;
    }
    // Safety: don't allow deleting config.json or config.json.bak
    if (strcmp(path, "/config.json") == 0 || strcmp(path, "/config.json.bak") == 0) {
        web_server->send(403, "application/json", "{\"error\":\"Cannot delete config files\"}");
        return;
    }
    if (sdcard_file_remove(path)) {
        web_server->send(200, "application/json", "{\"success\":true}");
    } else {
        web_server->send(404, "application/json", "{\"error\":\"File not found or delete failed\"}");
    }
}
```

Register all three routes in the server setup (find where `web_server->on("/api/config/upload", ...)` is registered):
```cpp
web_server->on("/api/sd/usage", HTTP_GET, handle_sd_usage);
web_server->on("/api/sd/list", HTTP_GET, handle_sd_list);
web_server->on("/api/sd/delete", HTTP_POST, handle_sd_delete);
```

Include ArduinoJson at top of config_server.cpp if not already included: `#include <ArduinoJson.h>`
  </action>
  <verify>PlatformIO build compiles: `pio run -e display 2>&1 | tail -5` shows SUCCESS</verify>
  <done>GET /api/sd/usage returns total/used/free MB; GET /api/sd/list returns directory listing; POST /api/sd/delete removes files (with config.json protection); sdcard_list_dir and sdcard_get_usage helpers added</done>
</task>

</tasks>

<verification>
- `pio run -e display` compiles without errors
- hw_input module replaces rotary_encoder entirely
- PCF8575 auto-detection logs address found/not found
- SD card HTTP endpoints registered alongside existing config endpoints
- I2C mutex used for all PCF8575 access (no bus contention with GT911 touch)
</verification>

<success_criteria>
- hw_input_init() scans TCA9548A channel 0 for PCF8575 at 0x20-0x27
- Buttons debounced at 50ms, encoder quadrature decoded with 80ms guard
- Button presses dispatch configured actions from AppConfig
- Encoder rotation dispatches based on encoder_mode (page_nav/volume/brightness/app_select/mode_cycle)
- App-select mode visually highlights focused widget, push fires its action
- SD card HTTP API provides usage, listing, and deletion
- Old rotary_encoder module replaced
</success_criteria>

<output>
After completion, create `.planning/phases/11-hardware-buttons-system-actions/11-02-SUMMARY.md`
</output>
