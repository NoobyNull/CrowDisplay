---
phase: 01-wired-command-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - platformio.ini
  - shared/protocol.h
  - display/main.cpp
  - display/display_hw.h
  - display/display_hw.cpp
  - display/touch.h
  - display/touch.cpp
  - bridge/main.cpp
autonomous: true

must_haves:
  truths:
    - "platformio.ini defines env:display and env:bridge as separate build targets"
    - "shared/protocol.h compiles identically from both display and bridge source trees"
    - "Skeleton display firmware compiles and boots on CrowPanel (shows blank screen, touch not wired yet)"
    - "Skeleton bridge firmware compiles for ESP32-S3 DevKitC-1"
  artifacts:
    - path: "platformio.ini"
      provides: "Multi-environment build config for display and bridge"
      contains: "[env:display]"
    - path: "platformio.ini"
      provides: "Bridge build environment"
      contains: "[env:bridge]"
    - path: "shared/protocol.h"
      provides: "SOF-framed binary protocol with CRC8"
      contains: "MSG_HOTKEY"
    - path: "display/display_hw.cpp"
      provides: "LovyanGFX RGB panel driver + LVGL buffer setup + GT911 touch with I2C mutex"
      contains: "i2c_mutex"
    - path: "display/touch.cpp"
      provides: "GT911 I2C polling with mutex protection"
      contains: "xSemaphoreTake"
  key_links:
    - from: "display/main.cpp"
      to: "display/display_hw.h"
      via: "display_init() and lvgl_init() calls"
      pattern: "display_init|lvgl_init"
    - from: "shared/protocol.h"
      to: "display/main.cpp"
      via: "#include"
      pattern: 'include.*protocol\.h'
    - from: "shared/protocol.h"
      to: "bridge/main.cpp"
      via: "#include"
      pattern: 'include.*protocol\.h'
---

<objective>
Restructure the monolithic project into a dual-firmware architecture (display + bridge) with a shared binary protocol header, and create skeleton firmware for both targets that compiles and boots.

Purpose: Establish the project structure, build system, shared protocol, and hardware abstraction modules that all subsequent plans depend on. This is the foundation -- no hotkey features yet, just the plumbing.

Output: Multi-env platformio.ini, shared/protocol.h with SOF+CRC8 framing, display firmware skeleton with working LovyanGFX + LVGL + I2C mutex-protected GT911 touch, bridge firmware skeleton that compiles.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-wired-command-foundation/01-RESEARCH.md
@src/main.cpp
@backup/main.cpp
@backup/usb_hid.h
@backup/display_driver.h
@backup/display_driver.cpp
@platformio.ini
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-env platformio.ini and shared protocol header</name>
  <files>
    platformio.ini
    shared/protocol.h
  </files>
  <action>
**platformio.ini changes:**

Replace the current `[env:test]` and `[env:running]` environments. Keep the `[env]` base section mostly intact. Add two new environments:

```ini
[env:display]
; CrowPanel 7.0" display firmware
src_dir = display
build_flags =
    ${env.build_flags}
    -DARDUINO_USB_MODE=1
    -DDISPLAY_UNIT
    -I shared

[env:bridge]
; ESP32-S3 DevKitC-1 USB HID bridge
src_dir = bridge
build_flags =
    ${env.build_flags}
    -DARDUINO_USB_MODE=0
    -DARDUINO_USB_CDC_ON_BOOT=0
    -DBRIDGE_UNIT
    -I shared
; Bridge does not need LovyanGFX or LVGL
lib_ignore = LovyanGFX, lvgl
```

Keep `[env:running]` commented out with a note "legacy BLE build" for reference. Remove `[env:test]`.

Update the `[env]` base to ensure `monitor_speed`, `upload_speed`, `upload_port` remain. Remove `ARDUINO_USB_CDC_ON_BOOT=0` from base build_flags (each env sets its own USB mode). Keep `-DBOARD_HAS_PSRAM`, `-DCORE_DEBUG_LEVEL=1`, `-DLV_CONF_INCLUDE_SIMPLE`, `-I src` in base.

**shared/protocol.h:**

Create the shared protocol header exactly as specified in the research doc (Pattern 1 + Pattern 2). This file must be a header-only implementation (all functions inline or static) so it compiles identically in both firmware targets.

Contents:
- `#pragma once` guard
- `#include <stdint.h>` and `#include <string.h>` (for memcpy)
- `PROTO_SOF = 0xAA`, `PROTO_MAX_PAYLOAD = 250`
- `enum MsgType : uint8_t` with `MSG_HOTKEY = 0x01`, `MSG_HOTKEY_ACK = 0x02`
- `struct __attribute__((packed)) HotkeyMsg` with `uint8_t modifiers` and `uint8_t keycode`
- `struct __attribute__((packed)) HotkeyAckMsg` with `uint8_t status`
- Full 256-byte CRC8/CCITT lookup table (poly 0x07, init 0x00) -- copy from research doc exactly
- `inline uint8_t crc8_calc(const uint8_t* data, size_t len)` function
- Modifier mask defines: `MOD_NONE=0x00`, `MOD_CTRL=0x01`, `MOD_SHIFT=0x02`, `MOD_ALT=0x04`, `MOD_GUI=0x08`

Do NOT include Arduino.h or any platform-specific headers in protocol.h -- it must be pure C/C++.
  </action>
  <verify>
Run `pio run -e display --dry-run` and `pio run -e bridge --dry-run` (or check that platformio.ini parses without errors). Verify shared/protocol.h exists and contains MSG_HOTKEY, crc8_table, and crc8_calc.
  </verify>
  <done>
platformio.ini has env:display and env:bridge. shared/protocol.h defines the binary protocol with SOF framing, message types, packed structs, and CRC8 implementation. Both environments reference shared/ via -I flag.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create display firmware skeleton with hardware abstraction and I2C mutex</name>
  <files>
    display/main.cpp
    display/display_hw.h
    display/display_hw.cpp
    display/touch.h
    display/touch.cpp
  </files>
  <action>
Extract and restructure the display hardware code from `src/main.cpp` into modular files. The goal is a booting display firmware with working touch -- no UI or UART yet.

**display/display_hw.h:**
```cpp
#pragma once
#include <cstdint>

#define SCREEN_WIDTH  800
#define SCREEN_HEIGHT 480

void display_init();   // Init LovyanGFX RGB panel + backlight
void lvgl_init();      // Init LVGL buffers, register display/touch drivers
void lvgl_tick();      // Call lv_timer_handler() -- call from loop()
```

**display/display_hw.cpp:**
Port the LGFX class definition from `src/main.cpp` (lines 19-70) verbatim -- it's proven hardware config. Also port:
- `disp_flush_cb` (lines 143-151)
- LVGL buffer allocation with `ps_malloc` (lines 402-404)
- Display and input driver registration (lines 406-418)

Key changes from current code:
- `display_init()` handles: PCA9557 touch reset sequence (lines 338-350), `lcd.begin()`, `lcd.fillScreen(TFT_BLACK)`, GT911 discovery (call `gt911_discover()` from touch module)
- `lvgl_init()` handles: `lv_init()`, buffer allocation, display driver registration, input driver registration (touch_read_cb comes from touch.h)
- `lvgl_tick()` is just `lv_timer_handler()`
- Remove the I2C bus scan and PCF8575 probing code (lines 357-385) -- that was debug-only and adds ~10s boot delay
- Include `<Wire.h>` and `<PCA9557.h>` for I2C init and touch reset

**display/touch.h:**
```cpp
#pragma once
#include <cstdint>
#include <lvgl.h>

void touch_init();    // Create I2C mutex, discover GT911
void touch_poll();    // Poll GT911 with mutex protection -- call from loop() at 20Hz
void touch_read_cb(lv_indev_drv_t *drv, lv_indev_data_t *data);  // LVGL callback

// I2C mutex helpers -- used by any module needing I2C
bool i2c_take(uint32_t timeout_ms = 10);
void i2c_give();
```

**display/touch.cpp:**
Port GT911 touch code from `src/main.cpp` (lines 82-220). Key changes:
- Create `SemaphoreHandle_t i2c_mutex` in `touch_init()` using `xSemaphoreCreateMutex()`
- `gt911_discover()` wraps each I2C probe in `i2c_take()`/`i2c_give()`
- `touch_poll()` acquires mutex at start, does the entire GT911 read sequence (status register, touch data, clear flag) atomically, releases mutex at end. If mutex unavailable, skip this poll cycle.
- `touch_read_cb()` simply returns the cached touch_x/touch_y/touch_down -- no I2C here
- Remove the periodic `Serial.printf` debug dumps (keep only error logging with rate-limit)
- `i2c_take()` and `i2c_give()` are public so other modules (future: PCA9557 operations) can use the mutex

Include `<freertos/FreeRTOS.h>` and `<freertos/semphr.h>` for mutex. Include `<Wire.h>` for I2C.

**display/main.cpp:**
Minimal skeleton that boots the display:
```cpp
#include <Arduino.h>
#include <lvgl.h>
#include "display_hw.h"
#include "touch.h"

static uint32_t touch_timer = 0;

void setup() {
    Serial.begin(115200);
    Serial.println("=== Display Unit Starting ===");

    Wire.begin(19, 20);  // I2C SDA=19, SCL=20

    touch_init();      // Create mutex, discover GT911
    display_init();    // LovyanGFX + PCA9557 reset
    lvgl_init();       // LVGL buffers + drivers

    // Placeholder: UI will be added in Plan 03
    lv_obj_t *label = lv_label_create(lv_scr_act());
    lv_label_set_text(label, "Display Unit Ready");
    lv_obj_center(label);

    Serial.println("Display setup complete");
}

void loop() {
    if (millis() - touch_timer >= 50) {
        touch_timer = millis();
        touch_poll();
    }
    lvgl_tick();
    delay(5);
}
```

Also create a minimal **bridge/main.cpp** skeleton:
```cpp
#include <Arduino.h>
#include "protocol.h"

void setup() {
    Serial.begin(115200);
    Serial.println("=== Bridge Unit Starting ===");
    // Placeholder: USB HID and UART will be added in Plan 02
}

void loop() {
    delay(10);
}
```

Wire.begin() must be called BEFORE touch_init() and display_init() because PCA9557 uses I2C. The order matters: Wire → touch_init (mutex + GT911 discover) → display_init (PCA9557 reset → LCD init) → lvgl_init (registers drivers).

Wait -- actually PCA9557 reset must happen before GT911 discover because PCA9557 controls the GT911 reset pin. So display_init() should include the PCA9557 reset sequence, and GT911 discovery should happen after. Adjust the order in display_init() and main.cpp accordingly:
1. Wire.begin(19, 20)
2. touch_init() -- creates mutex only, does NOT discover GT911 yet
3. display_init() -- PCA9557 reset sequence + lcd.begin()
4. gt911_discover() -- called after display_init since touch IC is now reset
5. lvgl_init() -- registers drivers

Expose `gt911_discover()` in touch.h and call it from main.cpp after display_init().
  </action>
  <verify>
Run `pio run -e display` -- firmware must compile without errors. Verify display_hw.cpp contains the LGFX class with correct GPIO pins (matching src/main.cpp). Verify touch.cpp creates an I2C mutex and wraps GT911 reads in xSemaphoreTake/xSemaphoreGive. Verify bridge/main.cpp compiles with `pio run -e bridge`.
  </verify>
  <done>
Display firmware skeleton compiles with LovyanGFX display driver, LVGL initialization, and mutex-protected GT911 touch polling. Bridge firmware skeleton compiles. Both share protocol.h. The display shows a "Display Unit Ready" label and responds to touch. I2C bus access is wrapped in FreeRTOS mutex (DISP-12 satisfied).
  </done>
</task>

</tasks>

<verification>
1. `pio run -e display` compiles without errors
2. `pio run -e bridge` compiles without errors
3. shared/protocol.h is included by both firmware targets
4. display/touch.cpp contains xSemaphoreCreateMutex and xSemaphoreTake/Give around all Wire operations
5. No I2C bus scan or PCF8575 debug code in new firmware (removed boot delay)
6. platformio.ini has env:display and env:bridge with correct build flags
</verification>

<success_criteria>
Both firmware targets compile cleanly. Display firmware boots on CrowPanel showing LVGL label with working touch input. Bridge firmware compiles for DevKitC-1. Shared protocol header defines SOF framing + CRC8 + message types. I2C mutex is in place.
</success_criteria>

<output>
After completion, create `.planning/phases/01-wired-command-foundation/01-01-SUMMARY.md`
</output>
