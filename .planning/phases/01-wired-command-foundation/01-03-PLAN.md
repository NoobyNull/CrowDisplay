---
phase: 01-wired-command-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - display/ui.h
  - display/ui.cpp
  - display/uart_link.h
  - display/uart_link.cpp
  - display/main.cpp
autonomous: true

must_haves:
  truths:
    - "Display shows 3 pages of 12 hotkey buttons each in a swipeable tabview layout"
    - "Each button shows an icon (LVGL symbol), text label, and is color-coded by function category"
    - "Buttons show visible press feedback on tap: background color darkens and button shrinks"
    - "Tapping a hotkey button sends a MSG_HOTKEY frame over UART with correct modifier mask and keycode"
    - "User can swipe left/right between hotkey pages, with tab indicators at the bottom"
  artifacts:
    - path: "display/ui.cpp"
      provides: "Multi-page LVGL tabview with color-coded hotkey buttons, icons, and press feedback"
      contains: "lv_tabview_create"
    - path: "display/ui.cpp"
      provides: "Hotkey definitions for 3 pages of 12 keys each"
      contains: "page1_hotkeys"
    - path: "display/uart_link.cpp"
      provides: "UART send with SOF framing for hotkey commands"
      contains: "uart_send"
    - path: "display/main.cpp"
      provides: "Display main loop integrating UI, touch, and UART"
      contains: "uart_link_init"
  key_links:
    - from: "display/ui.cpp"
      to: "display/uart_link.cpp"
      via: "Button callback calls uart_send_hotkey() to transmit command to bridge"
      pattern: "uart_send_hotkey|send_hotkey_to_bridge"
    - from: "display/ui.cpp"
      to: "shared/protocol.h"
      via: "Uses HotkeyMsg struct and modifier masks for UART payload"
      pattern: "HotkeyMsg|MOD_CTRL"
    - from: "display/main.cpp"
      to: "display/ui.h"
      via: "create_ui() called in setup()"
      pattern: "create_ui"
---

<objective>
Build the display-side multi-page hotkey UI and UART transmit module. When a user taps a button, the display sends a protocol-framed hotkey command over UART to the bridge.

Purpose: This is the user-facing side of the system. The display must render an attractive, responsive multi-page button grid and reliably transmit hotkey commands. Combined with Plan 02 (bridge), this completes the end-to-end hotkey pipeline.

Output: LVGL tabview with 3 pages of 12 buttons each (icons, labels, color coding, press feedback), UART transmit module with SOF framing, and updated display main loop.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-wired-command-foundation/01-RESEARCH.md
@.planning/phases/01-wired-command-foundation/01-01-SUMMARY.md
@backup/main.cpp
@backup/usb_hid.h
@shared/protocol.h
@display/display_hw.h
@display/touch.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-page hotkey UI with tabview, icons, colors, and press feedback</name>
  <files>
    display/ui.h
    display/ui.cpp
  </files>
  <action>
**display/ui.h:**
```cpp
#pragma once

void create_ui();  // Build the complete hotkey UI
```

**display/ui.cpp:**
Port and enhance the UI code from backup/main.cpp (lines 20-227). This is the richest existing implementation and maps directly to the Phase 1 requirements.

**Hotkey data structure** -- use the Hotkey struct from backup/usb_hid.h:
```cpp
struct Hotkey {
    const char *label;
    const char *description;
    uint8_t modifiers;
    uint8_t keycode;    // Changed from uint16_t to uint8_t to match protocol.h HotkeyMsg
    uint32_t color;
    const char *icon;   // LV_SYMBOL_* string
};
```

Note: The backup used `uint16_t key` for consumer control usage IDs. Phase 1 is keyboard-only (no consumer control), so `uint8_t keycode` is sufficient and matches the protocol. When consumer control is added in Phase 3, the protocol will need a separate message type.

**Hotkey definitions** -- adapt from backup/main.cpp pages but make ALL keys standard keyboard (no MOD_CONSUMER in Phase 1). Replace the 6 media key entries in page 3 with additional dev shortcuts:

Page 1 "General" (12 keys): Copy, Paste, Cut, Undo, Redo, Save, Select All, Find, New, Print, Close, Refresh -- exactly as in backup
Page 2 "Windows" (12 keys): Desktop, Task View, Lock, Explorer, Settings, Snap Left, Snap Right, Maximize, Minimize, Screenshot, Task Mgr, Alt+Tab -- exactly as in backup
Page 3 "Dev Tools" (12 keys): Replace media keys with keyboard-only shortcuts:
- Terminal (Ctrl+`), Comment (Ctrl+/), Format (Ctrl+Shift+F), Debug (F5), Build (Ctrl+Shift+B), Palette (Ctrl+Shift+P) -- keep from backup
- Add: Go to Line (Ctrl+G), Toggle Sidebar (Ctrl+B), Split Editor (Ctrl+\), Close All (Ctrl+K Ctrl+W → simplify to Ctrl+Shift+W), Zoom In (Ctrl+=), Zoom Out (Ctrl+-)

Use the same color palette from backup (CLR_RED through CLR_DARK). Each page uses a consistent color theme for visual categorization.

**HotkeyPage struct and pages[] array** -- same pattern as backup:
```cpp
struct HotkeyPage {
    const char *name;
    const Hotkey *hotkeys;
    uint8_t count;
};
```

**create_ui() function** -- adapt from backup/main.cpp create_ui():
1. Set dark background on active screen: `lv_color_hex(0x0f0f23)`
2. Create header bar (45px) with title "Hotkey Display" and status label showing "Ready"
3. Create tabview below header: `lv_tabview_create(lv_scr_act(), LV_DIR_BOTTOM, 45)` -- tabs at bottom, 45px tab bar
4. Style tab buttons: dark background, grey text, blue highlight on selected tab
5. Loop through pages[], add tab for each, call `create_hotkey_page()` for each tab

**create_hotkey_button()** -- adapt from backup/main.cpp (lines 120-167):
- Set button size to 170x90 (proven in backup)
- Normal style: bg_color from hotkey color, radius 12, shadow_width 8, shadow_ofs_y 4
- **Pressed style (DISP-03):**
  - `lv_obj_set_style_bg_color(btn, lv_color_darken(lv_color_hex(hk->color), LV_OPA_30), LV_STATE_PRESSED)` -- darken
  - `lv_obj_set_style_transform_width(btn, -3, LV_STATE_PRESSED)` -- shrink
  - `lv_obj_set_style_transform_height(btn, -3, LV_STATE_PRESSED)` -- shrink
- Column flex layout inside button: icon (montserrat_22) → label (montserrat_16) → description (montserrat_12, lighter color)

**Button event callback:**
- On `LV_EVENT_CLICKED`, extract Hotkey pointer from user data
- Call `send_hotkey_to_bridge(hk->modifiers, hk->keycode)` (from uart_link module, see Task 2)
- Update status label: `"Sent: Copy (Ctrl+C)"` format
- Log to Serial

**Important:** The callback does NOT directly call USB HID. The display sends a UART message; the bridge handles USB. This is the architectural separation.

Include `<lvgl.h>`, `"protocol.h"` (for modifier masks), and forward-declare or include `"uart_link.h"` for send function.

For special keys (KEY_TAB, KEY_ESC, KEY_LEFT_ARROW, KEY_F5, etc.), use the Arduino keyboard constants. These are defined in `USBHIDKeyboard.h` but we need them on the display side too. Define the needed key codes locally in ui.cpp (or a small header) since the display does not include USBHIDKeyboard.h:
```cpp
// Key codes matching USB HID usage table (same as Arduino USBHIDKeyboard)
#define KEY_TAB         0xB3
#define KEY_ESC         0xB1
#define KEY_F5          0xC4
#define KEY_LEFT_ARROW  0xD8
#define KEY_RIGHT_ARROW 0xD7
#define KEY_UP_ARROW    0xDA
#define KEY_DOWN_ARROW  0xD9
```
Verify these match the Arduino USBHIDKeyboard.h definitions by checking the backup code.
  </action>
  <verify>
Run `pio run -e display` -- must compile. Verify ui.cpp creates a tabview with 3 pages. Verify each button has darken + shrink on LV_STATE_PRESSED. Verify button callback calls send function (not USB HID directly). Count: at least 36 hotkey definitions (3 pages x 12).
  </verify>
  <done>
display/ui.cpp renders 3 pages of 12 color-coded hotkey buttons in an LVGL tabview with swipe navigation (DISP-01, DISP-02). Each button has icon + label + description (DISP-05) with category-based coloring (DISP-04). Press feedback via color darken + transform shrink (DISP-03). Button taps trigger UART send to bridge.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create display UART transmit module and wire up main loop</name>
  <files>
    display/uart_link.h
    display/uart_link.cpp
    display/main.cpp
  </files>
  <action>
**display/uart_link.h:**
```cpp
#pragma once
#include <cstdint>
#include "protocol.h"

void uart_link_init();
bool uart_send(MsgType type, const uint8_t *payload, uint8_t len);

// Convenience: send hotkey command to bridge
void send_hotkey_to_bridge(uint8_t modifiers, uint8_t keycode);

// Poll for incoming ACK messages (optional, for future use)
// Returns true if ACK received, status in out param
bool uart_poll_ack(uint8_t &status);
```

**display/uart_link.cpp:**
- `#include <HardwareSerial.h>` and `#include "protocol.h"`
- `HardwareSerial BridgeSerial(1)` -- UART1
- Define `DISPLAY_UART_TX 10` and `DISPLAY_UART_RX 11` (GPIO 10/11 on CrowPanel -- confirmed free on ESP32-S3)
- `DISPLAY_UART_BAUD 115200`

`uart_link_init()`:
- `BridgeSerial.begin(DISPLAY_UART_BAUD, SERIAL_8N1, DISPLAY_UART_RX, DISPLAY_UART_TX)`
- Log: "UART link ready (TX=GPIO10, RX=GPIO11)"

`uart_send()`:
- Build frame: SOF(1) + LEN(1) + TYPE(1) + PAYLOAD(0-250) + CRC8(1)
- Frame buffer: `uint8_t frame[4 + PROTO_MAX_PAYLOAD]` (stack allocated, max 254 bytes)
- `frame[0] = PROTO_SOF`
- `frame[1] = len`
- `frame[2] = (uint8_t)type`
- `memcpy(&frame[3], payload, len)` if len > 0
- `frame[3 + len] = crc8_calc(&frame[1], 2 + len)`
- Return `BridgeSerial.write(frame, 4 + len) == (size_t)(4 + len)`

`send_hotkey_to_bridge()`:
- Create `HotkeyMsg msg = { modifiers, keycode }`
- Call `uart_send(MSG_HOTKEY, (uint8_t*)&msg, sizeof(msg))`
- Log: `Serial.printf("UART TX: hotkey mod=0x%02X key=0x%02X\n", modifiers, keycode)`

`uart_poll_ack()`:
- Implement a simple FrameParser (same state machine as bridge side) to receive ACK frames
- If complete frame received and type == MSG_HOTKEY_ACK, extract status byte and return true
- Otherwise return false
- This is non-blocking -- just processes available bytes

**display/main.cpp -- update from skeleton:**

Replace the placeholder label with the full setup:

```cpp
#include <Arduino.h>
#include <Wire.h>
#include <lvgl.h>
#include "display_hw.h"
#include "touch.h"
#include "ui.h"
#include "uart_link.h"

static uint32_t touch_timer = 0;

void setup() {
    Serial.begin(115200);
    Serial.println("\n=== Display Unit Starting ===");

    Wire.begin(19, 20);

    touch_init();       // Create I2C mutex
    display_init();     // PCA9557 reset + LCD init
    gt911_discover();   // Find GT911 on I2C (after PCA9557 reset)
    lvgl_init();        // LVGL buffers + driver registration

    uart_link_init();   // UART1 to bridge

    create_ui();        // Build hotkey tabview UI
    Serial.println("Display setup complete");
}

void loop() {
    // Poll touch at ~20Hz
    if (millis() - touch_timer >= 50) {
        touch_timer = millis();
        touch_poll();
    }

    // Drive LVGL
    lvgl_tick();

    // Check for ACK from bridge (non-blocking)
    uint8_t ack_status;
    if (uart_poll_ack(ack_status)) {
        Serial.printf("ACK: status=%d\n", ack_status);
        // Future: update UI status indicator
    }

    delay(5);
}
```

The init order is critical and documented in Plan 01:
1. Wire.begin(19, 20) -- I2C bus
2. touch_init() -- creates mutex (no I2C yet)
3. display_init() -- PCA9557 reset sequence (uses I2C with mutex), LCD begin
4. gt911_discover() -- finds GT911 on I2C (uses mutex)
5. lvgl_init() -- registers display flush and touch read callbacks
6. uart_link_init() -- UART1 to bridge
7. create_ui() -- builds LVGL widget tree
  </action>
  <verify>
Run `pio run -e display` -- must compile cleanly. Verify display/uart_link.cpp implements uart_send() with SOF framing and CRC8. Verify display/main.cpp calls uart_link_init() and create_ui(). Verify send_hotkey_to_bridge() creates a HotkeyMsg and sends it via uart_send(MSG_HOTKEY, ...).
  </verify>
  <done>
Display firmware sends SOF-framed MSG_HOTKEY commands over UART when buttons are tapped (COMM-01, COMM-03). Main loop integrates touch polling, LVGL tick, UART ACK polling. Init sequence is correct: Wire → mutex → PCA9557 → GT911 → LVGL → UART → UI.
  </done>
</task>

</tasks>

<verification>
1. `pio run -e display` compiles without errors
2. display/ui.cpp has 3 pages of 12 hotkeys each (36 total buttons)
3. Each button has LV_STATE_PRESSED style with darken + transform shrink
4. Each button has icon (LV_SYMBOL_*), label, and description text
5. Button callback calls send_hotkey_to_bridge(), not USB HID directly
6. display/uart_link.cpp builds correct SOF-framed messages with CRC8
7. UART pins: GPIO 10 (TX) and GPIO 11 (RX) on display side
8. display/main.cpp init order: Wire → touch_init → display_init → gt911_discover → lvgl_init → uart_link_init → create_ui
</verification>

<success_criteria>
Display firmware compiles and renders a 3-page swipeable hotkey grid with colored buttons, icons, labels, and press feedback. Tapping a button transmits a properly framed MSG_HOTKEY message over UART. The display is ready for end-to-end testing with the bridge.
</success_criteria>

<output>
After completion, create `.planning/phases/01-wired-command-foundation/01-03-SUMMARY.md`
</output>
