---
phase: 01-wired-command-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - bridge/main.cpp
  - bridge/usb_hid.h
  - bridge/usb_hid.cpp
  - bridge/uart_link.h
  - bridge/uart_link.cpp
autonomous: true

must_haves:
  truths:
    - "Bridge ESP32-S3 appears as USB HID keyboard when plugged into PC (lsusb shows HID device)"
    - "Bridge receives a MSG_HOTKEY frame over UART and fires the corresponding keystroke on PC"
    - "Bridge supports modifier+key combos (Ctrl+C, Alt+Tab, GUI+L, Ctrl+Shift+Z, etc.)"
    - "Bridge sends MSG_HOTKEY_ACK back over UART after firing keystroke"
    - "Bridge ignores corrupted frames (bad CRC) and recovers to wait for next SOF"
  artifacts:
    - path: "bridge/usb_hid.cpp"
      provides: "USB HID keyboard initialization and keystroke firing"
      contains: "USBHIDKeyboard"
    - path: "bridge/uart_link.cpp"
      provides: "UART receive with SOF-framed state machine parser"
      contains: "FrameParser"
    - path: "bridge/main.cpp"
      provides: "Bridge main loop: UART poll -> parse -> fire HID -> send ACK"
      contains: "MSG_HOTKEY"
  key_links:
    - from: "bridge/uart_link.cpp"
      to: "shared/protocol.h"
      via: "FrameParser uses SOF framing and CRC8 validation"
      pattern: "crc8_calc|PROTO_SOF"
    - from: "bridge/main.cpp"
      to: "bridge/usb_hid.cpp"
      via: "fire_keystroke() called when MSG_HOTKEY received"
      pattern: "fire_keystroke"
    - from: "bridge/main.cpp"
      to: "bridge/uart_link.cpp"
      via: "uart_poll() called in loop, returns parsed frames"
      pattern: "uart_poll|uart_receive"
---

<objective>
Implement the bridge ESP32-S3 firmware: USB HID keyboard output, UART receive with protocol parsing, and the command dispatch loop that fires keystrokes when hotkey messages arrive.

Purpose: The bridge is the relay between the display and the PC. It must appear as a standard USB HID keyboard to the PC and translate incoming UART protocol frames into keystrokes. This is one of the two firmware targets that must work independently before end-to-end integration.

Output: Complete bridge firmware that initializes USB HID, listens on UART, parses SOF-framed messages, fires modifier+key combos, and sends ACK responses.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-wired-command-foundation/01-RESEARCH.md
@.planning/phases/01-wired-command-foundation/01-01-SUMMARY.md
@shared/protocol.h
@backup/usb_hid.h
@backup/usb_hid.cpp
@platformio.ini
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement bridge USB HID keyboard and UART receive modules</name>
  <files>
    bridge/usb_hid.h
    bridge/usb_hid.cpp
    bridge/uart_link.h
    bridge/uart_link.cpp
  </files>
  <action>
**bridge/usb_hid.h:**
```cpp
#pragma once
#include <cstdint>

void usb_hid_init();
void fire_keystroke(uint8_t modifiers, uint8_t keycode);
```

**bridge/usb_hid.cpp:**
Adapt from backup/usb_hid.cpp but simplified -- keyboard only, no consumer control (media keys deferred to Phase 3 per BRDG-04).

- `#include <USB.h>` and `#include <USBHIDKeyboard.h>`
- Static `USBHIDKeyboard Keyboard`
- `usb_hid_init()`: Call `Keyboard.begin()`, `USB.productName("HotkeyBridge")`, `USB.manufacturerName("CrowPanel")`, `USB.begin()`. Log to Serial.
- `fire_keystroke(uint8_t modifiers, uint8_t keycode)`:
  - Use modifier masks from protocol.h (MOD_CTRL=0x01, MOD_SHIFT=0x02, MOD_ALT=0x04, MOD_GUI=0x08)
  - If `modifiers & MOD_CTRL` → `Keyboard.press(KEY_LEFT_CTRL)`
  - If `modifiers & MOD_SHIFT` → `Keyboard.press(KEY_LEFT_SHIFT)`
  - If `modifiers & MOD_ALT` → `Keyboard.press(KEY_LEFT_ALT)`
  - If `modifiers & MOD_GUI` → `Keyboard.press(KEY_LEFT_GUI)`
  - `Keyboard.press(keycode)`
  - `delay(20)` -- minimum hold time for host to register
  - `Keyboard.releaseAll()`
  - Log: `Serial.printf("HID: mod=0x%02X key=0x%02X\n", modifiers, keycode)`

**bridge/uart_link.h:**
```cpp
#pragma once
#include <cstdint>
#include "protocol.h"

// Initialize UART1 for bridge-side communication
// Bridge UART pins: RX from display TX, TX to display RX
// Actual GPIO pins TBD based on bridge board -- use GPIO 18 (RX) and GPIO 17 (TX) as defaults
void uart_link_init();

// Poll UART for incoming data, feed to parser
// Returns true if a complete valid frame was received
// On return true, type/payload/payload_len are populated
bool uart_poll(uint8_t &type, uint8_t *payload, uint8_t &payload_len);

// Send a framed message over UART (for ACK responses)
bool uart_send(MsgType type, const uint8_t *payload, uint8_t len);
```

**bridge/uart_link.cpp:**
- `#include <HardwareSerial.h>` and `#include "protocol.h"`
- `HardwareSerial DisplaySerial(1)` -- UART1
- Define `BRIDGE_UART_RX 18` and `BRIDGE_UART_TX 17` (GPIO 17/18 on DevKitC-1 -- free pins)
- `BRIDGE_UART_BAUD 115200`

`uart_link_init()`:
- `DisplaySerial.begin(BRIDGE_UART_BAUD, SERIAL_8N1, BRIDGE_UART_RX, BRIDGE_UART_TX)`
- Log init message

Implement `FrameParser` struct exactly as in the research doc (state machine: WAIT_SOF → READ_LEN → READ_TYPE → READ_PAYLOAD → READ_CRC):
- Static `FrameParser parser` instance
- `feed(uint8_t byte)` returns true when valid frame received
- On CRC failure, log error and return to WAIT_SOF
- On length > PROTO_MAX_PAYLOAD, discard and return to WAIT_SOF

`uart_poll()`:
- While `DisplaySerial.available()`, read byte, feed to parser
- If parser returns true (valid frame), copy type/payload/len to output params, return true
- If no complete frame this cycle, return false
- Process at most 64 bytes per call to avoid blocking the main loop

`uart_send()`:
- Build frame: SOF + LEN + TYPE + PAYLOAD + CRC8
- `uint8_t frame[4 + len]`
- `frame[0] = PROTO_SOF`, `frame[1] = len`, `frame[2] = (uint8_t)type`
- Copy payload to `&frame[3]`
- `frame[3 + len] = crc8_calc(&frame[1], 2 + len)` -- CRC over LEN+TYPE+PAYLOAD
- `DisplaySerial.write(frame, 4 + len)`
- Return true if all bytes written
  </action>
  <verify>
Run `pio run -e bridge` -- firmware must compile. Verify usb_hid.cpp includes USB.h and USBHIDKeyboard.h. Verify uart_link.cpp implements the FrameParser state machine with CRC8 validation. Verify no consumer control code (deferred to Phase 3).
  </verify>
  <done>
bridge/usb_hid.cpp initializes USB HID keyboard with correct build flags (ARDUINO_USB_MODE=0, ARDUINO_USB_CDC_ON_BOOT=0). bridge/uart_link.cpp implements SOF-framed UART receive with state machine parser and CRC8 validation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire bridge main loop to dispatch hotkey commands</name>
  <files>
    bridge/main.cpp
  </files>
  <action>
Replace the skeleton bridge/main.cpp with the full dispatch loop:

```cpp
#include <Arduino.h>
#include "protocol.h"
#include "usb_hid.h"
#include "uart_link.h"

void setup() {
    Serial.begin(115200);  // Debug output on UART0 (GPIO 43/44)
    Serial.println("=== Bridge Unit Starting ===");

    usb_hid_init();
    Serial.println("USB HID keyboard initialized");

    uart_link_init();
    Serial.println("UART link initialized");

    Serial.println("Bridge ready - waiting for commands");
}

void loop() {
    uint8_t msg_type;
    uint8_t payload[PROTO_MAX_PAYLOAD];
    uint8_t payload_len;

    if (uart_poll(msg_type, payload, payload_len)) {
        switch (msg_type) {
            case MSG_HOTKEY: {
                if (payload_len >= sizeof(HotkeyMsg)) {
                    HotkeyMsg *cmd = (HotkeyMsg *)payload;
                    Serial.printf("CMD: hotkey mod=0x%02X key=0x%02X\n",
                                  cmd->modifiers, cmd->keycode);
                    fire_keystroke(cmd->modifiers, cmd->keycode);

                    // Send ACK
                    HotkeyAckMsg ack = { 0 };  // status = 0 (success)
                    uart_send(MSG_HOTKEY_ACK, (uint8_t *)&ack, sizeof(ack));
                } else {
                    Serial.printf("ERR: hotkey payload too short (%d)\n", payload_len);
                    HotkeyAckMsg ack = { 1 };  // status = 1 (error)
                    uart_send(MSG_HOTKEY_ACK, (uint8_t *)&ack, sizeof(ack));
                }
                break;
            }
            default:
                Serial.printf("WARN: unknown msg type 0x%02X\n", msg_type);
                break;
        }
    }

    delay(1);  // Yield to other tasks; keep responsive
}
```

Key design decisions:
- `delay(1)` instead of `delay(5)` -- bridge has no LVGL overhead, should be maximally responsive to incoming commands
- Debug serial on UART0 (Serial) -- this goes to GPIO 43/44 or the built-in USB-to-serial chip, NOT the native USB port (which is HID-only)
- ACK sent immediately after keystroke fires -- display can use this for feedback
- Unknown message types logged but not fatal -- forward compatibility
- Payload length validated before casting to packed struct -- prevents buffer underread
  </action>
  <verify>
Run `pio run -e bridge` -- firmware must compile cleanly. Verify main.cpp includes protocol.h, usb_hid.h, and uart_link.h. Verify the dispatch loop handles MSG_HOTKEY and sends MSG_HOTKEY_ACK. Verify error handling for short payloads and unknown message types.
  </verify>
  <done>
Bridge firmware is complete: initializes USB HID keyboard, listens on UART1, parses incoming MSG_HOTKEY frames via state machine, fires modifier+key combos via USBHIDKeyboard, and returns MSG_HOTKEY_ACK. Ready for integration with display firmware.
  </done>
</task>

</tasks>

<verification>
1. `pio run -e bridge` compiles without errors
2. bridge/main.cpp handles MSG_HOTKEY by calling fire_keystroke() and sending ACK
3. bridge/usb_hid.cpp supports all modifier combos: Ctrl, Shift, Alt, GUI, and combinations
4. bridge/uart_link.cpp FrameParser rejects bad CRC and oversized payloads
5. No LVGL or LovyanGFX code in bridge firmware
6. USB build flags: ARDUINO_USB_MODE=0, ARDUINO_USB_CDC_ON_BOOT=0
</verification>

<success_criteria>
Bridge firmware compiles and, when flashed to ESP32-S3 DevKitC-1 with correct USB flags, appears as a USB HID keyboard. The UART receive state machine correctly parses SOF-framed binary messages and the dispatch loop fires keystrokes for MSG_HOTKEY commands.
</success_criteria>

<output>
After completion, create `.planning/phases/01-wired-command-foundation/01-02-SUMMARY.md`
</output>
