---
phase: 03-stats-display-companion-app
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/protocol.h
  - bridge/usb_hid.h
  - bridge/usb_hid.cpp
  - bridge/main.cpp
autonomous: true

must_haves:
  truths:
    - "Bridge enumerates as composite USB HID device with Keyboard + ConsumerControl + Vendor interfaces"
    - "Bridge receives raw HID output reports from host via USBHIDVendor and relays as MSG_STATS over ESP-NOW"
    - "Bridge fires USB consumer control codes (play/pause, volume, mute, next/prev) when MSG_MEDIA_KEY received from display"
    - "Protocol defines MSG_STATS, MSG_MEDIA_KEY, StatsPayload, and MediaKeyMsg types"
  artifacts:
    - path: "shared/protocol.h"
      provides: "MSG_STATS, MSG_MEDIA_KEY, StatsPayload, MediaKeyMsg"
      contains: "MSG_STATS"
    - path: "bridge/usb_hid.h"
      provides: "usb_hid_init, fire_keystroke, fire_media_key, poll_vendor_hid"
      exports: ["fire_media_key", "poll_vendor_hid"]
    - path: "bridge/usb_hid.cpp"
      provides: "Composite USB HID with Keyboard + ConsumerControl + Vendor"
      contains: "USBHIDVendor"
    - path: "bridge/main.cpp"
      provides: "MSG_MEDIA_KEY dispatch and vendor HID polling"
      contains: "MSG_MEDIA_KEY"
  key_links:
    - from: "bridge/usb_hid.cpp"
      to: "USBHIDVendor"
      via: "Vendor.available() + Vendor.read() in poll_vendor_hid()"
      pattern: "Vendor\\.available"
    - from: "bridge/main.cpp"
      to: "bridge/usb_hid.cpp"
      via: "poll_vendor_hid() called in loop(), espnow_send(MSG_STATS)"
      pattern: "poll_vendor_hid"
    - from: "bridge/main.cpp"
      to: "bridge/usb_hid.cpp"
      via: "fire_media_key() called on MSG_MEDIA_KEY receipt"
      pattern: "fire_media_key"
---

<objective>
Extend the shared protocol and bridge firmware to support three new capabilities: (1) USB consumer control for media keys, (2) USBHIDVendor for receiving stats data from the companion app, and (3) ESP-NOW relay of stats data to the display.

Purpose: The bridge becomes the data hub -- it receives stats from the PC over USB HID vendor reports and relays them to the display over ESP-NOW, while also gaining media key support via USB consumer control.

Output: Updated protocol.h with new message types, bridge firmware with composite USB HID (Keyboard + ConsumerControl + Vendor), stats relay logic, and media key dispatch.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stats-display-companion-app/03-RESEARCH.md
@.planning/phases/03-stats-display-companion-app/03-CONTEXT.md
@shared/protocol.h
@bridge/usb_hid.h
@bridge/usb_hid.cpp
@bridge/main.cpp
@bridge/espnow_link.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend protocol.h with stats and media key message types</name>
  <files>shared/protocol.h</files>
  <action>
Add to the MsgType enum in shared/protocol.h:
- MSG_STATS = 0x03 (Bridge -> Display: stats payload)
- MSG_MEDIA_KEY = 0x04 (Display -> Bridge: consumer control key)

Add two new packed payload structs:

StatsPayload (10 bytes):
- uint8_t cpu_percent (0-100)
- uint8_t ram_percent (0-100)
- uint8_t gpu_percent (0-100, 0xFF = unavailable)
- uint8_t cpu_temp (Celsius, 0xFF = unavailable)
- uint8_t gpu_temp (Celsius, 0xFF = unavailable)
- uint8_t disk_percent (0-100)
- uint16_t net_up_kbps (KB/s, little-endian)
- uint16_t net_down_kbps (KB/s, little-endian)

MediaKeyMsg (2 bytes):
- uint16_t consumer_code (USB HID consumer control usage code, e.g., 0x00CD for play/pause)

Keep all existing types (HotkeyMsg, HotkeyAckMsg) unchanged. Keep existing CRC8 table and SOF framing unchanged.
  </action>
  <verify>The file compiles: `grep -c "MSG_STATS\|MSG_MEDIA_KEY\|StatsPayload\|MediaKeyMsg" shared/protocol.h` returns 4+ matches.</verify>
  <done>protocol.h contains MSG_STATS (0x03), MSG_MEDIA_KEY (0x04), StatsPayload struct (10 bytes packed), MediaKeyMsg struct (2 bytes packed).</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade bridge to composite USB HID with ConsumerControl + Vendor + stats relay</name>
  <files>bridge/usb_hid.h, bridge/usb_hid.cpp, bridge/main.cpp</files>
  <action>
**bridge/usb_hid.h:** Add two new function declarations:
- `void fire_media_key(uint16_t consumer_code);`
- `bool poll_vendor_hid(uint8_t *buf, size_t &len);` -- returns true if data available, fills buf/len

**bridge/usb_hid.cpp:** Refactor to composite USB HID device:
1. Add includes: `#include <USBHIDConsumerControl.h>` and `#include <USBHIDVendor.h>`
2. Add static instances alongside existing Keyboard:
   - `static USBHIDConsumerControl ConsumerControl;`
   - `static USBHIDVendor Vendor(63, false);` -- 63-byte reports, no size prepend
3. In usb_hid_init(): Keep existing D+/D- low trick (pins 19/20). Call `Keyboard.begin()`, `ConsumerControl.begin()`, `Vendor.begin()` ALL before `USB.begin()`. Keep `USB.productName("HotkeyBridge")` and `USB.manufacturerName("CrowPanel")`. Keep `USB.begin()` and `delay(1000)`.
4. Add fire_media_key(): Call `ConsumerControl.press(consumer_code)`, `delay(20)`, `ConsumerControl.release()`.
5. Add poll_vendor_hid(): Check `Vendor.available()`, if so read into buf with `Vendor.read(buf, 63)`, set len, return true. Else return false.
6. Keep fire_keystroke() unchanged.

**bridge/main.cpp:** Add stats relay and media key handling:
1. In loop(), add call to poll_vendor_hid() to check for incoming stats data from companion. If data received and len >= sizeof(StatsPayload), relay via `espnow_send(MSG_STATS, buf, sizeof(StatsPayload))`.
2. In the espnow_poll() switch, add case for MSG_MEDIA_KEY: parse MediaKeyMsg from payload, call `fire_media_key(cmd->consumer_code)`. Log the consumer code.
3. Keep all existing MSG_HOTKEY handling unchanged.

Build with: `cd /data/Elcrow-Display-hotkeys && pio run -e bridge`
  </action>
  <verify>`cd /data/Elcrow-Display-hotkeys && pio run -e bridge` compiles without errors.</verify>
  <done>Bridge firmware compiles with composite USB HID (Keyboard + ConsumerControl + Vendor). poll_vendor_hid() reads incoming HID reports and relays as MSG_STATS. MSG_MEDIA_KEY fires consumer control codes.</done>
</task>

</tasks>

<verification>
- `pio run -e bridge` compiles cleanly
- protocol.h has MSG_STATS=0x03, MSG_MEDIA_KEY=0x04, StatsPayload (10 bytes), MediaKeyMsg (2 bytes)
- bridge/usb_hid.cpp includes USBHIDConsumerControl and USBHIDVendor
- bridge/main.cpp handles MSG_MEDIA_KEY case and calls poll_vendor_hid() in loop
</verification>

<success_criteria>
Bridge firmware compiles with all three USB HID devices (Keyboard, ConsumerControl, Vendor). Protocol header defines all message types and payload structs needed by display and companion in subsequent plans.
</success_criteria>

<output>
After completion, create `.planning/phases/03-stats-display-companion-app/03-01-SUMMARY.md`
</output>
