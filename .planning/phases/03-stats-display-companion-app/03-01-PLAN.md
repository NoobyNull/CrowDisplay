---
phase: 03-stats-display-companion-app
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/protocol.h
  - bridge/usb_hid.h
  - bridge/usb_hid.cpp
  - bridge/serial_stats.h
  - bridge/serial_stats.cpp
  - bridge/main.cpp
autonomous: true

must_haves:
  truths:
    - "Bridge receives stats frames from companion via UART0 and forwards them to display over ESP-NOW as MSG_STATS"
    - "Bridge receives media key commands from display over ESP-NOW and fires them via USB consumer control"
    - "USB HID keyboard continues to work alongside consumer control (no regression)"
  artifacts:
    - path: "shared/protocol.h"
      provides: "MSG_STATS, MSG_MEDIA_KEY types, StatsMsg and MediaKeyMsg structs"
      contains: "MSG_STATS"
    - path: "bridge/usb_hid.cpp"
      provides: "USBHIDConsumerControl alongside USBHIDKeyboard"
      contains: "USBHIDConsumerControl"
    - path: "bridge/serial_stats.h"
      provides: "UART0 stats frame parser interface"
      exports: ["poll_companion_stats"]
    - path: "bridge/serial_stats.cpp"
      provides: "SOF-framed binary parser for companion stats on Serial (UART0)"
      contains: "poll_companion_stats"
    - path: "bridge/main.cpp"
      provides: "Stats relay loop and media key dispatch"
      contains: "MSG_MEDIA_KEY"
  key_links:
    - from: "bridge/serial_stats.cpp"
      to: "shared/protocol.h"
      via: "StatsMsg struct parsing"
      pattern: "StatsMsg"
    - from: "bridge/main.cpp"
      to: "bridge/usb_hid.cpp"
      via: "fire_media_key() call"
      pattern: "fire_media_key"
    - from: "bridge/main.cpp"
      to: "bridge/espnow_link.cpp"
      via: "espnow_send(MSG_STATS, ...)"
      pattern: "MSG_STATS"
---

<objective>
Extend the shared protocol with stats and media key message types, add USB consumer control (media keys) to the bridge, and add UART0 stats reception + ESP-NOW relay so the bridge can forward PC stats from the companion app to the display.

Purpose: The bridge is the central hub -- it receives stats from the companion app via its UART USB-C port and relays them wirelessly to the display, while also handling media key commands from the display as USB consumer control reports.

Output: Updated protocol.h with new message types, bridge firmware with consumer control + stats relay capability.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stats-display-companion-app/03-RESEARCH.md
@shared/protocol.h
@bridge/main.cpp
@bridge/usb_hid.h
@bridge/usb_hid.cpp
@bridge/espnow_link.h
@bridge/espnow_link.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend protocol and add USB consumer control to bridge</name>
  <files>shared/protocol.h, bridge/usb_hid.h, bridge/usb_hid.cpp</files>
  <action>
1. In `shared/protocol.h`, add to the MsgType enum:
   - `MSG_MEDIA_KEY = 0x03` (Display -> Bridge: consumer control key)
   - `MSG_STATS = 0x10` (Bridge -> Display: system stats update)

2. In `shared/protocol.h`, add packed payload structs after existing ones:
   ```cpp
   struct __attribute__((packed)) StatsMsg {
       uint8_t  cpu_percent;      // 0-100
       uint8_t  ram_percent;      // 0-100
       uint8_t  gpu_percent;      // 0-100 (0xFF = unavailable)
       uint16_t net_up_kbps;      // KB/s upstream (little-endian)
       uint16_t net_down_kbps;    // KB/s downstream (little-endian)
       uint8_t  disk_percent;     // 0-100
   };

   struct __attribute__((packed)) MediaKeyMsg {
       uint16_t consumer_key;     // USB HID consumer control usage code
   };
   ```

3. In `shared/protocol.h`, add media key constants after modifier masks:
   ```cpp
   #define MEDIA_PLAY_PAUSE    0x00CD
   #define MEDIA_STOP          0x00B7
   #define MEDIA_NEXT          0x00B5
   #define MEDIA_PREV          0x00B6
   #define MEDIA_VOL_UP        0x00E9
   #define MEDIA_VOL_DOWN      0x00EA
   #define MEDIA_MUTE          0x00E2
   ```

4. In `bridge/usb_hid.h`, add declaration: `void fire_media_key(uint16_t consumer_key);`

5. In `bridge/usb_hid.cpp`:
   - Add `#include <USBHIDConsumerControl.h>`
   - Add static instance: `static USBHIDConsumerControl ConsumerControl;`
   - In `usb_hid_init()`, add `ConsumerControl.begin();` BEFORE `USB.begin()` (after `Keyboard.begin()`)
   - Add `fire_media_key()` function: `ConsumerControl.press(consumer_key); delay(20); ConsumerControl.release();`
   - Keep all existing keyboard functionality unchanged
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && pio run -e running` (bridge env). Must compile with no errors. Verify USBHIDConsumerControl is resolved by the Arduino ESP32 core (no missing header).
  </verify>
  <done>protocol.h has MSG_STATS, MSG_MEDIA_KEY, StatsMsg, MediaKeyMsg, and media key constants. Bridge compiles with both USBHIDKeyboard and USBHIDConsumerControl initialized before USB.begin(). fire_media_key() exists and is callable.</done>
</task>

<task type="auto">
  <name>Task 2: Add UART0 stats reception and main loop integration</name>
  <files>bridge/serial_stats.h, bridge/serial_stats.cpp, bridge/main.cpp</files>
  <action>
1. Create `bridge/serial_stats.h`:
   ```cpp
   #pragma once
   #include "protocol.h"

   // Poll UART0 (Serial) for incoming stats frames from companion app.
   // Returns true when a complete, valid StatsMsg frame has been received.
   // Uses the existing SOF-framed protocol from protocol.h.
   // Handles interleaved debug text gracefully (skips non-SOF bytes).
   bool poll_companion_stats(StatsMsg &stats);
   ```

2. Create `bridge/serial_stats.cpp`:
   - Implement a SOF frame parser on `Serial` (UART0, GPIO 43/44 -- the board's second USB-C port).
   - Parser state machine: WAIT_SOF -> READ_LEN -> READ_TYPE -> READ_PAYLOAD -> CHECK_CRC
   - On valid frame with type == MSG_STATS and payload_len == sizeof(StatsMsg), copy payload into output struct and return true.
   - Ignore any frame that is not MSG_STATS (this allows debug text to pass through harmlessly since ASCII bytes will never form a valid SOF+CRC frame).
   - Process up to 64 bytes per call to avoid blocking the main loop (same pattern as Phase 1 UART polling -- 64-byte poll limit per cycle).
   - Use `crc8_calc()` from protocol.h for CRC validation.

3. Update `bridge/main.cpp`:
   - Add `#include "serial_stats.h"`
   - In `loop()`, after the existing `espnow_poll()` block, add stats polling:
     ```cpp
     StatsMsg stats;
     if (poll_companion_stats(stats)) {
         // Relay stats to display over ESP-NOW
         espnow_send(MSG_STATS, (uint8_t *)&stats, sizeof(stats));
     }
     ```
   - In the `espnow_poll()` switch statement, add a case for `MSG_MEDIA_KEY`:
     ```cpp
     case MSG_MEDIA_KEY: {
         if (payload_len >= sizeof(MediaKeyMsg)) {
             MediaKeyMsg *mk = (MediaKeyMsg *)payload;
             Serial.printf("CMD: media key=0x%04X\n", mk->consumer_key);
             fire_media_key(mk->consumer_key);
         }
         break;
     }
     ```
   - Ensure `serial_stats.cpp` is added to `build_src_filter` in platformio.ini if needed (check existing filter pattern -- if using `+<../bridge/*>` glob it should be auto-included).
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && pio run -e running`. Must compile with no errors. Verify serial_stats.cpp is linked (check build output for the file).
  </verify>
  <done>Bridge firmware compiles and includes: (1) UART0 stats frame parser that reads SOF-framed StatsMsg from Serial, (2) stats relay from UART0 to ESP-NOW broadcast as MSG_STATS, (3) media key command handler that fires USB consumer control reports when MSG_MEDIA_KEY received from display.</done>
</task>

</tasks>

<verification>
- `pio run -e running` compiles the bridge firmware with zero errors
- protocol.h contains MSG_STATS (0x10), MSG_MEDIA_KEY (0x03), StatsMsg (8 bytes), MediaKeyMsg (2 bytes)
- bridge/main.cpp handles both MSG_HOTKEY and MSG_MEDIA_KEY from ESP-NOW
- bridge/main.cpp polls UART0 for companion stats and relays via ESP-NOW
- No regressions: existing hotkey flow (MSG_HOTKEY -> fire_keystroke) unchanged
</verification>

<success_criteria>
Bridge firmware compiles and contains all three new capabilities: USB consumer control, UART0 stats reception, and ESP-NOW stats relay. Protocol header defines the shared message types used by all three devices (companion, bridge, display).
</success_criteria>

<output>
After completion, create `.planning/phases/03-stats-display-companion-app/03-01-SUMMARY.md`
</output>
