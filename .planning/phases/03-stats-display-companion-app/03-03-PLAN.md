---
phase: 03-stats-display-companion-app
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - companion/companion.py
  - companion/stats_collector.py
  - companion/serial_sender.py
  - companion/requirements.txt
autonomous: true

must_haves:
  truths:
    - "Companion app launches on Linux and begins streaming stats with no manual configuration"
    - "Stats include CPU, RAM, GPU (optional), network up/down speeds, and disk usage"
    - "Stats are sent at 1-2 Hz as SOF-framed binary protocol matching protocol.h format"
    - "Serial port is auto-detected (no hardcoded /dev/ttyUSB0)"
    - "GPU monitoring gracefully falls back to sentinel 0xFF when unavailable"
  artifacts:
    - path: "companion/companion.py"
      provides: "Main entry point daemon loop"
      contains: "main"
    - path: "companion/stats_collector.py"
      provides: "System stats collection via psutil + optional pynvml"
      contains: "psutil"
    - path: "companion/serial_sender.py"
      provides: "SOF-framed binary serial sender matching protocol.h"
      contains: "PROTO_SOF"
    - path: "companion/requirements.txt"
      provides: "Python dependencies"
      contains: "psutil"
  key_links:
    - from: "companion/serial_sender.py"
      to: "shared/protocol.h"
      via: "Same SOF frame format, CRC8 table, MSG_STATS type"
      pattern: "0xAA"
    - from: "companion/companion.py"
      to: "companion/stats_collector.py"
      via: "collect_stats() call in main loop"
      pattern: "collect_stats"
    - from: "companion/companion.py"
      to: "companion/serial_sender.py"
      via: "send_frame() for each stats sample"
      pattern: "send_frame"
---

<objective>
Create the Python companion app that collects live system stats (CPU, RAM, GPU, network, disk) and streams them to the bridge via USB serial at 1-2 Hz using the SOF-framed binary protocol.

Purpose: This is the PC-side data source that feeds the display's stats header. It auto-detects the bridge's UART USB-C port and requires no manual configuration.

Output: Working Python companion app in companion/ directory.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stats-display-companion-app/03-RESEARCH.md
@shared/protocol.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stats collector and serial sender modules</name>
  <files>companion/stats_collector.py, companion/serial_sender.py, companion/requirements.txt</files>
  <action>
1. Create `companion/requirements.txt`:
   ```
   psutil>=5.9.0
   pyserial>=3.5
   ```
   (pynvml is optional -- listed in comments only, not as hard dependency)

2. Create `companion/stats_collector.py`:
   - Import psutil.
   - Module-level state for network delta calculation:
     - `_prev_net = None` (previous net_io_counters)
     - `_prev_time = None` (previous timestamp)
   - `collect_stats() -> dict`:
     - CPU: `psutil.cpu_percent(interval=None)` -- non-blocking, requires prior call to prime. Call `psutil.cpu_percent(interval=None)` once at module import to prime the counter.
     - RAM: `psutil.virtual_memory().percent`
     - GPU: Try importing pynvml. On success: `pynvml.nvmlInit()`, get handle for device 0, `nvmlDeviceGetUtilizationRates(handle).gpu`. On any exception (ImportError, NVMLError): return 0xFF sentinel. Cache the import result so we don't retry every cycle.
     - Network: Call `psutil.net_io_counters()`. Compute delta bytes_sent and bytes_recv since last call. Divide by time delta to get bytes/sec. Convert to KB/s (integer, clamped to uint16 max 65535). On first call (no previous), return 0.
     - Disk: `psutil.disk_usage('/').percent`
   - Return dict with keys: cpu, ram, gpu, net_up_kbps, net_down_kbps, disk

3. Create `companion/serial_sender.py`:
   - Constants matching protocol.h EXACTLY:
     ```python
     PROTO_SOF = 0xAA
     MSG_STATS = 0x10
     ```
   - Copy the FULL CRC8 lookup table from protocol.h (all 256 entries). The table in the research doc is truncated -- copy from the actual `shared/protocol.h` file which has the complete table.
   - `crc8(data: bytes) -> int`: Standard CRC8/CCITT using the lookup table.
   - `pack_stats(stats: dict) -> bytes`:
     - Use `struct.pack('<BBBHHB', cpu, ram, gpu, net_up, net_down, disk)` -- little-endian to match ESP32.
     - Clamp all percent values to 0-100 range (except gpu which can be 0xFF).
     - Clamp network values to 0-65535.
   - `build_frame(msg_type: int, payload: bytes) -> bytes`:
     - Frame format: [SOF] [LENGTH] [TYPE] [PAYLOAD] [CRC8]
     - LENGTH = len(payload) + 1 (payload + type byte) -- wait, check protocol.h: frame is `[SOF] [LENGTH] [TYPE] [PAYLOAD] [CRC8]` where CRC is over LENGTH+TYPE+PAYLOAD. Look at the bridge parser to determine what LENGTH means.
     - From protocol.h comment: "CRC8 is computed over LENGTH + TYPE + PAYLOAD bytes". And from bridge serial_stats.cpp (Plan 01 will create this), the LENGTH field = number of bytes after LENGTH and before CRC, i.e., TYPE + PAYLOAD length. So LENGTH = 1 + len(payload).
     - Build: `bytes([SOF, length, msg_type]) + payload + bytes([crc])` where crc = crc8(bytes([length, msg_type]) + payload).
   - `send_frame(port, msg_type: int, payload: bytes)`:
     - Build frame and write to serial port.
   - `find_bridge_port() -> str or None`:
     - Use `serial.tools.list_ports.comports()`.
     - Look for common USB-to-UART VID/PIDs: CP2102 (10C4:EA60), CH340 (1A86:7523), CP2102N (10C4:EA60), FTDI (0403:6001).
     - If found, return `port.device`.
     - Fallback: return first `/dev/ttyUSB*` device found.
     - If nothing found, return None.
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && python3 -c "from companion.stats_collector import collect_stats; print(collect_stats())"` -- should print a dict with cpu, ram, gpu, net_up_kbps, net_down_kbps, disk values. Run `python3 -c "from companion.serial_sender import crc8, pack_stats, build_frame; print(build_frame(0x10, pack_stats({'cpu':50,'ram':60,'gpu':255,'net_up_kbps':100,'net_down_kbps':200,'disk':70})).hex())"` -- should print a hex string starting with 'aa'.
  </verify>
  <done>stats_collector.py collects all 6 stats with graceful GPU fallback. serial_sender.py builds SOF-framed binary messages with correct CRC8 matching protocol.h. Auto-detect finds the bridge serial port.</done>
</task>

<task type="auto">
  <name>Task 2: Create companion main entry point with daemon loop</name>
  <files>companion/companion.py</files>
  <action>
1. Create `companion/companion.py`:
   - Shebang: `#!/usr/bin/env python3`
   - Import stats_collector and serial_sender modules.
   - `main()`:
     - Print banner: "CrowPanel Companion - System Stats Streamer"
     - Auto-detect serial port via `find_bridge_port()`. If None, print error message listing expected devices and exit with code 1.
     - Open serial port at 115200 baud, timeout=0.1.
     - Print "Connected to {port} at 115200 baud"
     - Prime the CPU counter: call `psutil.cpu_percent(interval=None)` (first call returns 0, subsequent calls return real delta).
     - Enter main loop (while True):
       - Call `collect_stats()` to gather current stats.
       - Pack into binary: `pack_stats(stats)`
       - Send frame: `send_frame(port, MSG_STATS, payload)`
       - Print stats to terminal for debugging (one line, overwrite with \r):
         `f"\rCPU:{cpu}% RAM:{ram}% GPU:{gpu_str} UP:{up}K DN:{dn}K DSK:{disk}%"`
       - Sleep 0.5 seconds (2 Hz update rate).
     - Handle KeyboardInterrupt: print "Shutting down", close port, exit cleanly.
     - Handle serial.SerialException: print error, attempt reconnect after 2s delay (simple retry loop).
   - `if __name__ == '__main__': main()`

2. Create `companion/__init__.py` (empty file, makes companion a package for imports).
  </action>
  <verify>
Run `cd /data/Elcrow-Display-hotkeys && python3 companion/companion.py --help 2>&1 || python3 companion/companion.py 2>&1 | head -5` -- should print the banner and either connect or show "no serial port found" error (expected if bridge not plugged in). Verify it does not crash with an import error.
  </verify>
  <done>Companion app runs as a standalone Python script. On launch it auto-detects the bridge serial port, collects system stats via psutil, and streams SOF-framed binary StatsMsg at 2 Hz. Handles missing serial port gracefully. Handles Ctrl+C cleanly.</done>
</task>

</tasks>

<verification>
- `python3 -c "from companion.stats_collector import collect_stats; print(collect_stats())"` returns valid stats dict
- `python3 -c "from companion.serial_sender import crc8; assert crc8(b'') == 0"` passes (empty CRC is 0x00)
- `python3 companion/companion.py` launches without import errors (may fail on serial port if bridge not connected -- that is expected)
- requirements.txt lists psutil and pyserial
- CRC8 table in serial_sender.py matches protocol.h exactly (256 entries)
- Frame format: SOF(0xAA) + LENGTH + TYPE(0x10) + 8-byte payload + CRC8
</verification>

<success_criteria>
Companion app exists as a self-contained Python package that auto-detects the bridge serial port, collects CPU/RAM/GPU/network/disk stats at 2 Hz, and streams them as SOF-framed binary messages compatible with the bridge's UART0 parser. GPU monitoring is optional with graceful fallback.
</success_criteria>

<output>
After completion, create `.planning/phases/03-stats-display-companion-app/03-03-SUMMARY.md`
</output>
