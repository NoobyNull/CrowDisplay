---
phase: 03-stats-display-companion-app
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - companion/hotkey_companion.py
  - companion/hotkey-companion.service
  - companion/99-hotkey-bridge.rules
  - companion/requirements.txt
autonomous: true
user_setup:
  - service: udev
    why: "Non-root access to HID device"
    env_vars: []
    dashboard_config:
      - task: "Install udev rule and reload"
        location: "sudo cp companion/99-hotkey-bridge.rules /etc/udev/rules.d/ && sudo udevadm control --reload-rules && sudo udevadm trigger"
  - service: systemd
    why: "Auto-start companion on login"
    env_vars: []
    dashboard_config:
      - task: "Install and enable service"
        location: "cp companion/hotkey-companion.service ~/.config/systemd/user/ && systemctl --user enable --now hotkey-companion"

must_haves:
  truths:
    - "Companion auto-detects bridge by VID 0x303A and product string HotkeyBridge"
    - "Companion collects CPU%, RAM%, GPU%, CPU temp, GPU temp, network speed, disk% and packs into 10-byte StatsPayload"
    - "Companion writes HID output report to bridge at 1 Hz via hidapi"
    - "Companion handles missing NVIDIA GPU gracefully (sends 0xFF for gpu_percent and gpu_temp)"
    - "Network stats show KB/s rate (delta calculation) not cumulative bytes"
    - "Companion runs as CLI tool and as systemd user service"
  artifacts:
    - path: "companion/hotkey_companion.py"
      provides: "Stats collection and HID report writing"
      min_lines: 80
    - path: "companion/hotkey-companion.service"
      provides: "Systemd user service unit"
      contains: "ExecStart"
    - path: "companion/99-hotkey-bridge.rules"
      provides: "Udev rule for non-root HID access"
      contains: "303a"
    - path: "companion/requirements.txt"
      provides: "Python dependencies"
      contains: "hidapi"
  key_links:
    - from: "companion/hotkey_companion.py"
      to: "bridge USBHIDVendor"
      via: "hidapi h.write() with StatsPayload bytes"
      pattern: "h\\.write"
    - from: "companion/hotkey_companion.py"
      to: "shared/protocol.h StatsPayload"
      via: "struct.pack matching StatsPayload layout"
      pattern: "struct\\.pack"
---

<objective>
Create the Python companion app that collects live system metrics and streams them to the bridge over USB HID output reports at 1 Hz.

Purpose: This is the data source for the stats header on the display. Without the companion, no stats appear. The companion must be zero-config: auto-detect the bridge, collect metrics, and stream.

Output: Single-file Python companion app, systemd user service file, udev rules for non-root HID access, and requirements.txt.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-stats-display-companion-app/03-RESEARCH.md
@.planning/phases/03-stats-display-companion-app/03-CONTEXT.md
@.planning/phases/03-stats-display-companion-app/03-01-SUMMARY.md
@shared/protocol.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Python companion app with stats collection and HID output</name>
  <files>companion/hotkey_companion.py, companion/requirements.txt</files>
  <action>
**companion/requirements.txt:**
```
hidapi>=0.14
psutil>=6.0
pynvml>=12.0
```

**companion/hotkey_companion.py:** Single-file Python script. Use Python with hidapi per user decision (research suggested Python as well).

Structure:
1. **Imports:** hid, psutil, struct, time, sys, signal, logging
2. **Constants:**
   - VENDOR_ID = 0x303A (Espressif)
   - PRODUCT_ID = 0x0002 (default ESP32-S3)
   - PRODUCT_STRING = "HotkeyBridge"
   - UPDATE_INTERVAL = 1.0 (1 Hz per discretion choice)
   - STATS_FORMAT = '<BBBBBBhh' (matches StatsPayload: 6 uint8 + 2 int16 = 10 bytes)

3. **find_bridge() -> bytes | None:**
   - Call hid.enumerate(VENDOR_ID, PRODUCT_ID)
   - Filter for entries where product_string == PRODUCT_STRING
   - Among matches, prefer the one with usage_page >= 0xFF00 (vendor-defined). If usage_page not available in enumerate results (some platforms), try each path and check.
   - Return the path (bytes) of the vendor HID interface, or None if not found.
   - Log all discovered devices for debugging.

4. **GPU stats collection (try/except wrapped):**
   - Try: import pynvml, nvmlInit(), get handle for GPU 0, get utilization rates and temperature
   - Except (ImportError, pynvml.NVMLError, Exception): gpu_percent=0xFF, gpu_temp=0xFF
   - Also try AMD fallback: read /sys/class/drm/card0/device/gpu_busy_percent if it exists. For AMD GPU temp, look in /sys/class/drm/card0/device/hwmon/hwmon*/temp1_input.
   - Make GPU init happen once at startup, not every loop iteration.

5. **collect_stats(prev_net, prev_time) -> (bytes, net_counters, time):**
   - cpu_percent: int(psutil.cpu_percent(interval=None)) -- interval=None uses cached value from previous call
   - ram_percent: int(psutil.virtual_memory().percent)
   - disk_percent: int(psutil.disk_usage('/').percent)
   - cpu_temp: iterate psutil.sensors_temperatures() looking for 'coretemp', 'k10temp', 'zenpower', 'acpitz'. Take first current temp found. Default 0xFF.
   - gpu_percent, gpu_temp: from GPU collector (NVIDIA or AMD or 0xFF)
   - Network delta: curr_net = psutil.net_io_counters(), dt = time.time() - prev_time, net_up_kbps = int((curr_net.bytes_sent - prev_net.bytes_sent) / dt / 1024), net_down_kbps = int((curr_net.bytes_recv - prev_net.bytes_recv) / dt / 1024). Clamp to 0-65535 range (uint16 max).
   - Pack with struct.pack(STATS_FORMAT, cpu, ram, gpu, cpu_temp, gpu_temp, disk, net_up, net_down)
   - Return (packed_bytes, curr_net, curr_time)

6. **main():**
   - Setup logging (INFO level, timestamped)
   - Setup signal handler for SIGINT/SIGTERM for clean shutdown
   - Call psutil.cpu_percent() once to initialize (first call always returns 0)
   - Find bridge. If not found, log and retry every 5 seconds (bridge may not be plugged in yet).
   - Open HID device with hid.Device(path=path)
   - Log connection info (product, manufacturer, serial)
   - Initialize prev_net = psutil.net_io_counters(), prev_time = time.time()
   - Main loop (while running):
     - time.sleep(UPDATE_INTERVAL)
     - Collect stats with delta calculation
     - Write to HID: h.write(b'\x00' + packed_stats). The leading 0x00 is the report ID byte for hidapi on Linux. If the vendor device has a specific report ID, use that instead. Start with 0x00 and note in comments that this may need adjustment based on actual report ID assignment.
     - Handle IOError/OSError on write (device disconnected): close, wait, retry find_bridge
   - On exit, close HID device cleanly

7. **Shebang and entry point:**
   - `#!/usr/bin/env python3` at top
   - `if __name__ == '__main__': main()` at bottom
   - Make file executable (chmod +x in verify step)

8. **Error handling strategy:**
   - Bridge not found: retry every 5s with log message
   - GPU unavailable: silently use 0xFF, log once at startup
   - HID write fails: assume disconnect, close and retry discovery
   - psutil call fails: use 0 or 0xFF for that metric, continue
  </action>
  <verify>
`python3 -c "import ast; ast.parse(open('companion/hotkey_companion.py').read()); print('Syntax OK')"` succeeds. `chmod +x companion/hotkey_companion.py`.
  </verify>
  <done>companion/hotkey_companion.py is syntactically valid Python, collects all 8 metrics, packs into StatsPayload format, writes HID reports at 1 Hz, handles GPU absence and device disconnection gracefully.</done>
</task>

<task type="auto">
  <name>Task 2: Create systemd service and udev rules</name>
  <files>companion/hotkey-companion.service, companion/99-hotkey-bridge.rules</files>
  <action>
**companion/99-hotkey-bridge.rules:**
```
# Allow non-root access to HotkeyBridge USB HID device
# Install: sudo cp 99-hotkey-bridge.rules /etc/udev/rules.d/
# Reload: sudo udevadm control --reload-rules && sudo udevadm trigger
KERNEL=="hidraw*", ATTRS{idVendor}=="303a", ATTRS{idProduct}=="0002", TAG+="uaccess"
```

**companion/hotkey-companion.service:**
```ini
[Unit]
Description=Hotkey Bridge Companion - System Stats Streamer
Documentation=https://github.com/user/elcrow-display-hotkeys
After=graphical-session.target

[Service]
Type=simple
ExecStart=/usr/bin/python3 %h/path/to/hotkey_companion.py
Restart=on-failure
RestartSec=5
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=default.target
```

Note: The ExecStart path should use `%h` (home directory) since this is a user service. Use a reasonable default path like `%h/.local/bin/hotkey_companion.py`. Add a comment at top explaining how to adjust the path.

Both files should have clear installation instructions in comments at the top.
  </action>
  <verify>Files exist and contain expected content: `test -f companion/hotkey-companion.service && test -f companion/99-hotkey-bridge.rules && echo "OK"`</verify>
  <done>Systemd user service file and udev rules file exist with installation instructions in comments.</done>
</task>

</tasks>

<verification>
- companion/hotkey_companion.py parses as valid Python
- companion/hotkey_companion.py contains find_bridge(), collect_stats(), struct.pack with StatsPayload format
- companion/requirements.txt lists hidapi, psutil, pynvml
- companion/hotkey-companion.service is valid systemd unit
- companion/99-hotkey-bridge.rules contains uaccess rule for 303a:0002
</verification>

<success_criteria>
Companion app is a complete, syntactically valid Python script that auto-detects the bridge, collects all required metrics (CPU, RAM, GPU, temps, network, disk), packs them into the StatsPayload binary format, and writes HID reports at 1 Hz. Deployment files (systemd service, udev rules, requirements.txt) are ready for user installation.
</success_criteria>

<output>
After completion, create `.planning/phases/03-stats-display-companion-app/03-03-SUMMARY.md`
</output>
