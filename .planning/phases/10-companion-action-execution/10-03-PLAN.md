---
phase: 10-companion-action-execution
plan: 03
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - companion/ui/button_editor.py
  - companion/ui/editor_main.py
  - companion/ui/no_scroll_combo.py
autonomous: true

must_haves:
  truths:
    - "Editor action type dropdown shows 4 options: Hotkey, Media Key, Launch App, Shell Command, Open URL"
    - "Selecting Launch App shows an app picker that auto-fills launch_command and launch_wm_class"
    - "Selecting Shell Command shows a text input for the command"
    - "Selecting Open URL shows a text input for the URL"
    - "Selecting Hotkey shows the existing keyboard shortcut recorder"
    - "Test button fires the configured action immediately on the PC"
    - "Scroll wheel over unfocused dropdown widgets does not change their value"
    - "Editor window opens maximized (expanded, not fullscreen)"
    - "Focus-or-launch toggle is visible when Launch App action type is selected"
  artifacts:
    - path: "companion/ui/no_scroll_combo.py"
      provides: "NoScrollComboBox widget that ignores wheel events when unfocused"
      contains: "class NoScrollComboBox"
    - path: "companion/ui/button_editor.py"
      provides: "Overhauled editor with 5 action types and per-type input widgets"
      contains: "ACTION_LAUNCH_APP"
    - path: "companion/ui/editor_main.py"
      provides: "Test button, window maximize, scroll wheel fix applied"
      contains: "showMaximized"
  key_links:
    - from: "companion/ui/button_editor.py"
      to: "companion/config_manager.py"
      via: "imports new action type constants"
      pattern: "ACTION_LAUNCH_APP.*ACTION_SHELL_CMD.*ACTION_OPEN_URL"
    - from: "companion/ui/button_editor.py"
      to: "companion/ui/no_scroll_combo.py"
      via: "uses NoScrollComboBox instead of QComboBox"
      pattern: "NoScrollComboBox"
---

<objective>
Overhaul the editor UI to support 5 action types with per-type input widgets, add a test button, fix dropdown scroll wheel hijacking, and open the window maximized.

Purpose: Users need to configure the new action types (Launch App, Shell Command, Open URL) from the editor, and the UX bugs (scroll wheel, window size) need fixing.
Output: Updated button_editor.py with action type system, new no_scroll_combo.py, updated editor_main.py.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-companion-action-execution/10-CONTEXT.md
@.planning/phases/10-companion-action-execution/10-RESEARCH.md
@.planning/phases/10-companion-action-execution/10-01-SUMMARY.md
@companion/ui/button_editor.py
@companion/ui/editor_main.py
@companion/config_manager.py
@companion/app_scanner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: NoScrollComboBox + button editor overhaul for 5 action types</name>
  <files>companion/ui/no_scroll_combo.py, companion/ui/button_editor.py</files>
  <action>
1. Create companion/ui/no_scroll_combo.py:
   ```python
   from PySide6.QtWidgets import QComboBox
   from PySide6.QtCore import Qt

   class NoScrollComboBox(QComboBox):
       """QComboBox that ignores wheel events when not focused.
       Prevents accidental value changes when scrolling the editor panel."""
       def __init__(self, parent=None):
           super().__init__(parent)
           self.setFocusPolicy(Qt.StrongFocus)

       def wheelEvent(self, event):
           if self.hasFocus():
               super().wheelEvent(event)
           else:
               event.ignore()
   ```

2. Overhaul companion/ui/button_editor.py:

   a. Add imports:
      - from companion.config_manager import ACTION_LAUNCH_APP, ACTION_SHELL_CMD, ACTION_OPEN_URL
      - from companion.ui.no_scroll_combo import NoScrollComboBox
      - from companion.app_scanner import scan_applications
      - Add QCheckBox to imports if not already present

   b. Replace ALL QComboBox usage with NoScrollComboBox:
      - action_type_combo -> NoScrollComboBox
      - media_key_combo -> NoScrollComboBox

   c. Update action_type_combo to have 5 items:
      - "Keyboard Shortcut" -> ACTION_HOTKEY (0)
      - "Media Key" -> ACTION_MEDIA_KEY (1)
      - "Launch App" -> ACTION_LAUNCH_APP (2)
      - "Shell Command" -> ACTION_SHELL_CMD (3)
      - "Open URL" -> ACTION_OPEN_URL (4)

   d. Add new widgets for the new action types:

      Launch App section:
      - self.app_picker_combo = NoScrollComboBox() -- populated with scan_applications() results, display "App Name", store AppEntry as user data
      - self.app_picker_combo.currentIndexChanged.connect(self._on_app_selected)
      - self.launch_cmd_input = QLineEdit() -- shows the Exec command (auto-filled from app picker, but editable)
      - self.launch_wm_class_input = QLineEdit() -- shows WM_CLASS (auto-filled from app picker)
      - self.focus_or_launch_check = QCheckBox("Focus existing window if running")
      - self.focus_or_launch_check.setChecked(True)
      - self.focus_or_launch_check.stateChanged.connect callback to emit update
      - All hidden by default

      Shell Command section:
      - self.shell_cmd_input = QLineEdit() -- placeholder "e.g., notify-send 'Hello'"
      - self.shell_cmd_input.textChanged.connect(self._on_shell_cmd_changed)
      - Hidden by default

      Open URL section:
      - self.url_input = QLineEdit() -- placeholder "https://example.com"
      - self.url_input.textChanged.connect(self._on_url_changed)
      - Hidden by default

   e. Add labels for each section: self.launch_label, self.shell_label, self.url_label (hidden by default)

   f. Update _update_action_type_visibility(action_type) to show/hide the correct widgets:
      - ACTION_HOTKEY: show keyboard_recorder + shortcut_label, hide all others
      - ACTION_MEDIA_KEY: show media_key_combo + media_key_label, hide all others
      - ACTION_LAUNCH_APP: show app_picker_combo, launch_cmd_input, launch_wm_class_input, focus_or_launch_check, launch_label. Hide keyboard recorder, media key, shell, url.
      - ACTION_SHELL_CMD: show shell_cmd_input + shell_label. Hide all others.
      - ACTION_OPEN_URL: show url_input + url_label. Hide all others.

   g. Update action_type_combo.setCurrentIndex in load_button to handle 5 types:
      Find the index where itemData matches the action_type value.

   h. Update load_button to populate new fields:
      - launch_cmd_input.setText(button_dict.get("launch_command", ""))
      - launch_wm_class_input.setText(button_dict.get("launch_wm_class", ""))
      - focus_or_launch_check.setChecked(button_dict.get("launch_focus_or_launch", True))
      - shell_cmd_input.setText(button_dict.get("shell_command", ""))
      - url_input.setText(button_dict.get("url", ""))

   i. Update get_button to include new fields:
      - Always include launch_command, launch_wm_class, launch_focus_or_launch, shell_command, url in the returned dict
      - Values come from respective input widgets

   j. Add _on_app_selected handler:
      When an app is selected from app_picker_combo:
      - Get the AppEntry from currentData()
      - Auto-fill launch_cmd_input with app.exec_cmd
      - Auto-fill launch_wm_class_input with app.wm_class (or app.name as fallback)
      - Emit update

   k. Lazy-load applications list: populate app_picker_combo on first show or when action type changes to LAUNCH_APP. Cache the results. Add a "(Custom)" entry at the top for manual entry.

   l. Layout changes: add the new widgets to the QVBoxLayout in logical order:
      After "Action Type:" section, add all action-specific sections (they show/hide dynamically):
      - Shortcut section (existing)
      - Media Key section (existing)
      - Launch App section (new)
      - Shell Command section (new)
      - Open URL section (new)

   m. Connect textChanged signals for launch_cmd_input, launch_wm_class_input, shell_cmd_input, url_input to _emit_update (guarded by self._updating).
  </action>
  <verify>
   Run `cd /data/Elcrow-Display-hotkeys && python -c "
from PySide6.QtWidgets import QApplication
import sys
app = QApplication.instance() or QApplication(sys.argv)
from companion.ui.button_editor import ButtonEditor
editor = ButtonEditor()
# Check action type combo has 5 items
assert editor.action_type_combo.count() == 5, f'Expected 5 action types, got {editor.action_type_combo.count()}'
# Check NoScrollComboBox is used
from companion.ui.no_scroll_combo import NoScrollComboBox
assert isinstance(editor.action_type_combo, NoScrollComboBox), 'action_type_combo should be NoScrollComboBox'
print('OK')
"` -- prints OK.
  </verify>
  <done>ButtonEditor has 5 action types with per-type input widgets. NoScrollComboBox prevents scroll wheel hijacking. App picker auto-fills launch_command and launch_wm_class from .desktop files.</done>
</task>

<task type="auto">
  <name>Task 2: Test button, window maximize, and scroll wheel fix in editor_main</name>
  <files>companion/ui/editor_main.py</files>
  <action>
1. Window maximize:
   - In the EditorMainWindow.__init__ (or wherever the window is created), add `self.showMaximized()` after window setup.
   - If there's a self.resize() or self.setMinimumSize() call, keep it as the minimum but start maximized.

2. Test button:
   - Add a "Test Action" button to the button editor panel area (or to editor_main.py's properties panel section).
   - When clicked, it reads the current button's action configuration from the editor and calls execute_action directly:
     ```python
     from companion.action_executor import execute_action
     from companion.config_manager import get_config_manager
     ```
   - Since execute_action expects a config_manager and page+widget indices, and the test should fire the action as currently configured in the editor (which may not be saved yet), create a helper:
     ```python
     def _on_test_action(self):
         """Fire the currently configured action directly on the PC."""
         button_data = self.button_editor.get_button()
         # Create a temporary config_manager-like lookup
         # Or directly dispatch based on action_type from button_data
         from companion.action_executor import (
             _exec_launch_app, _exec_shell_cmd, _exec_open_url,
             _exec_keyboard_shortcut, _exec_media_key
         )
         from companion.config_manager import (
             ACTION_HOTKEY, ACTION_MEDIA_KEY, ACTION_LAUNCH_APP,
             ACTION_SHELL_CMD, ACTION_OPEN_URL
         )
         action_type = button_data.get("action_type", ACTION_HOTKEY)
         if action_type == ACTION_LAUNCH_APP:
             _exec_launch_app(button_data)
         elif action_type == ACTION_SHELL_CMD:
             _exec_shell_cmd(button_data)
         elif action_type == ACTION_OPEN_URL:
             _exec_open_url(button_data)
         elif action_type == ACTION_MEDIA_KEY:
             _exec_media_key(button_data)
         elif action_type == ACTION_HOTKEY:
             _exec_keyboard_shortcut(button_data)
     ```
   - Wire this up to a QPushButton labeled "Test Action" placed near the Apply button in the properties panel.
   - Run the test action on a background thread to avoid freezing the UI:
     ```python
     threading.Thread(target=self._on_test_action, daemon=True).start()
     ```

3. Scroll wheel fix:
   - Replace any remaining QComboBox instances in editor_main.py with NoScrollComboBox.
   - Import NoScrollComboBox from companion.ui.no_scroll_combo.
   - Search for all QComboBox() instantiations in editor_main.py and replace with NoScrollComboBox().
   - Also replace QSpinBox instances with a similar pattern if needed -- but the primary issue is dropdowns, so focus on QComboBox.

4. Add QSpinBox scroll wheel fix if any exist in editor_main.py:
   - QSpinBox has the same scroll wheel issue. Apply setFocusPolicy(Qt.StrongFocus) to any QSpinBox instances in editor_main.py that appear in scrollable areas.
  </action>
  <verify>
   Run `cd /data/Elcrow-Display-hotkeys && python -c "
from PySide6.QtWidgets import QApplication
import sys
app = QApplication.instance() or QApplication(sys.argv)
from companion.ui.editor_main import EditorMainWindow
# Just verify it imports without error
print('OK')
"` -- prints OK.
   Grep for showMaximized in editor_main.py to confirm window starts maximized.
   Grep for 'Test' in editor_main.py to confirm test button exists.
  </verify>
  <done>Editor window opens maximized. Test Action button fires the currently configured action on the PC. All QComboBox instances in editor_main.py replaced with NoScrollComboBox.</done>
</task>

</tasks>

<verification>
1. `python -c "from companion.ui.no_scroll_combo import NoScrollComboBox"` succeeds
2. `python -c "from companion.ui.button_editor import ButtonEditor"` succeeds
3. grep confirms 5 action type items in button_editor.py action_type_combo
4. grep confirms showMaximized in editor_main.py
5. grep confirms NoScrollComboBox usage in both button_editor.py and editor_main.py
6. grep confirms "Test" button in editor_main.py
7. No QComboBox() instantiations remain in button_editor.py or editor_main.py (all replaced with NoScrollComboBox)
</verification>

<success_criteria>
- Action type dropdown has 5 options: Keyboard Shortcut, Media Key, Launch App, Shell Command, Open URL
- Each action type shows the appropriate input widgets and hides irrelevant ones
- App picker populates from .desktop files and auto-fills launch_command + launch_wm_class
- Focus-or-launch checkbox visible when Launch App is selected
- Test Action button fires the current action config directly (without display/bridge round-trip)
- All dropdown widgets use NoScrollComboBox (no scroll wheel hijacking)
- Editor window opens maximized
- get_button() returns all new fields (launch_command, shell_command, url, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/10-companion-action-execution/10-03-SUMMARY.md`
</output>
