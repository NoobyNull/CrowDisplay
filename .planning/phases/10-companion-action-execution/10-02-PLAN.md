---
phase: 10-companion-action-execution
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - companion/action_executor.py
  - companion/hotkey_companion.py
  - companion/app_scanner.py
autonomous: true

must_haves:
  truths:
    - "Companion reads vendor HID input reports on a background thread and dispatches button presses to the action executor"
    - "Action executor launches apps (with focus-or-launch), runs shell commands, opens URLs, simulates keyboard shortcuts, and simulates media keys"
    - "Shell commands containing sudo are blocked"
    - "Config auto-reloads when the JSON file changes on disk (debounced)"
    - "Action execution never blocks the stats streaming loop"
  artifacts:
    - path: "companion/action_executor.py"
      provides: "Action execution logic for all 5 action types"
      contains: "def execute_action"
    - path: "companion/hotkey_companion.py"
      provides: "Vendor HID read thread and config file watcher"
      contains: "_vendor_read_thread"
    - path: "companion/app_scanner.py"
      provides: "StartupWMClass extraction from .desktop files"
      contains: "StartupWMClass"
  key_links:
    - from: "companion/hotkey_companion.py"
      to: "companion/action_executor.py"
      via: "vendor read thread calls execute_action on button press"
      pattern: "execute_action"
    - from: "companion/action_executor.py"
      to: "companion/config_manager.py"
      via: "looks up widget by page+widget index"
      pattern: "config_manager.*get_widget"
---

<objective>
Implement the companion-side action execution pipeline: a vendor HID read thread receives button presses from the bridge, looks up the configured action, and executes it (launch app, shell command, URL, keyboard shortcut, or media key). Add config file auto-reload via watchdog.

Purpose: This is the core behavior change -- buttons on the display now trigger rich actions on the PC instead of blind keyboard shortcuts.
Output: New action_executor.py module, updated hotkey_companion.py with read thread and config watcher, updated app_scanner.py with WM_CLASS extraction.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/10-companion-action-execution/10-CONTEXT.md
@.planning/phases/10-companion-action-execution/10-RESEARCH.md
@.planning/phases/10-companion-action-execution/10-01-SUMMARY.md
@companion/hotkey_companion.py
@companion/config_manager.py
@companion/app_scanner.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Action executor module + app_scanner WM_CLASS</name>
  <files>companion/action_executor.py, companion/app_scanner.py</files>
  <action>
1. Create companion/action_executor.py with these functions:

   - Import ACTION_HOTKEY, ACTION_MEDIA_KEY, ACTION_LAUNCH_APP, ACTION_SHELL_CMD, ACTION_OPEN_URL from config_manager
   - Import MOD_CTRL, MOD_SHIFT, MOD_ALT, MOD_GUI from config_manager

   - execute_action(config_manager, page_idx: int, widget_idx: int):
     Looks up widget via config_manager.get_widget(page_idx, widget_idx). If None, log warning and return. Dispatch by action_type to the appropriate handler.

   - _exec_launch_app(widget):
     Get launch_command, launch_wm_class, launch_focus_or_launch from widget.
     If launch_command empty, log warning, return.
     If focus_or_launch enabled and wm_class set, call _try_focus_window. If focused, return.
     Strip .desktop Exec format codes: re.sub(r'%[uUfFdDnNickvm]', '', exec_cmd).strip()
     Launch via subprocess.Popen(clean_cmd, shell=True, stdout=DEVNULL, stderr=DEVNULL)
     Log the action.

   - _exec_shell_cmd(widget):
     Get shell_command. If empty, return.
     Block sudo: if "sudo" in cmd.split(), log warning and return.
     Launch via subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     Log the action.

   - _exec_open_url(widget):
     Get url. If empty, return.
     Use webbrowser.open(url). Log the action.

   - _exec_keyboard_shortcut(widget):
     Get modifiers and keycode from widget.
     Build key combo string for ydotool: map MOD_CTRL->"ctrl", MOD_SHIFT->"shift", MOD_ALT->"alt", MOD_GUI->"super".
     Convert USB HID keycode to Linux key name. Build a mapping dict from HID keycodes to ydotool key names. For common keys: 0x04-0x1D -> 'a'-'z', 0x1E-0x27 -> '1'-'0', 0x28 -> 'enter', 0x29 -> 'esc', 0x2A -> 'backspace', 0x2B -> 'tab', 0x2C -> 'space', 0x39 -> 'capslock', 0x3A-0x45 -> 'f1'-'f12', 0x4F -> 'right', 0x50 -> 'left', 0x51 -> 'down', 0x52 -> 'up', 0x4A -> 'home', 0x4D -> 'end', 0x4B -> 'pageup', 0x4E -> 'pagedown', 0x4C -> 'delete', 0x49 -> 'insert'. For printable ASCII keys that don't have a named key, use the character directly.
     Try ydotool first: subprocess.Popen(["ydotool", "key", key_combo], stdout=DEVNULL, stderr=DEVNULL)
     If ydotool not found (shutil.which returns None), try xdotool as fallback: subprocess.Popen(["xdotool", "key", key_combo])
     If neither available, log error.

   - _exec_media_key(widget):
     Get consumer_code from widget.
     Map consumer codes to ydotool key names:
       0xCD -> "playpause", 0xB5 -> "nextsong", 0xB6 -> "previoussong",
       0xB7 -> "stopcd", 0xE9 -> "volumeup", 0xEA -> "volumedown", 0xE2 -> "mute"
     Use subprocess.Popen(["ydotool", "key", key_name], stdout=DEVNULL, stderr=DEVNULL)
     If ydotool not available, log warning.

   - _try_focus_window(wm_class: str) -> bool:
     If wmctrl available (shutil.which), run subprocess.run(["wmctrl", "-x", "-a", wm_class], capture_output=True, timeout=2). Return True if returncode == 0.
     Otherwise return False.

2. In companion/app_scanner.py:
   - In the scan_applications() function, after reading exec_cmd and categories, also read:
     wm_class = entry.get("StartupWMClass", "")
   - Add wm_class field to the AppEntry dataclass (after icon_path, default "")
   - Store wm_class in the AppEntry constructor call
  </action>
  <verify>
   Run `cd /data/Elcrow-Display-hotkeys && python -c "from companion.action_executor import execute_action; print('OK')"` -- prints OK.
   Run `cd /data/Elcrow-Display-hotkeys && python -c "from companion.app_scanner import AppEntry; print(hasattr(AppEntry, '__dataclass_fields__') and 'wm_class' in AppEntry.__dataclass_fields__)"` -- prints True.
  </verify>
  <done>action_executor.py exists with execute_action dispatching to 5 action type handlers. app_scanner.py extracts StartupWMClass from .desktop files.</done>
</task>

<task type="auto">
  <name>Task 2: Vendor HID read thread + config file watcher in companion</name>
  <files>companion/hotkey_companion.py</files>
  <action>
1. Add imports at top of hotkey_companion.py:
   ```python
   from companion.action_executor import execute_action
   from companion.config_manager import get_config_manager
   ```
   Also add MSG_BUTTON_PRESS = 0x0B to the message type constants section.

2. Add a threading.Lock for HID device access. Create it before the main loop:
   ```python
   hid_lock = threading.Lock()
   ```
   Wrap ALL existing device.write() calls in `with hid_lock:` blocks:
   - In the main stats loop: `with hid_lock: device.write(...)`
   - In send_power_state: `with hid_lock: device.write(...)`
   - In send_time_sync: `with hid_lock: device.write(...)`
   - In send_notification_to_display: `with hid_lock: device.write(...)`

3. Add vendor HID read thread function:
   ```python
   def _vendor_read_thread(device, hid_lock, config_mgr):
       """Background thread: reads vendor HID input reports from bridge."""
       global running
       while running:
           try:
               with hid_lock:
                   data = device.read(63, timeout_ms=100)
               if data and len(data) >= 3:
                   msg_type = data[0]
                   if msg_type == MSG_BUTTON_PRESS:
                       page_idx = data[1]
                       widget_idx = data[2]
                       logging.info("Button press: page=%d widget=%d", page_idx, widget_idx)
                       # Execute action on a separate thread to avoid blocking reads
                       threading.Thread(
                           target=execute_action,
                           args=(config_mgr, page_idx, widget_idx),
                           daemon=True
                       ).start()
           except (IOError, OSError):
               logging.warning("Vendor HID read error, device may have disconnected")
               break
           except Exception as exc:
               logging.debug("Vendor read thread error: %s", exc)
   ```

4. Add config file watcher using watchdog:
   ```python
   def _start_config_watcher(config_path, config_mgr):
       """Start watching config file for changes, reload on modification."""
       try:
           from watchdog.observers import Observer
           from watchdog.events import FileSystemEventHandler
       except ImportError:
           logging.warning("watchdog not installed -- config auto-reload disabled. "
                          "Install with: pip install watchdog")
           return None

       class ConfigReloadHandler(FileSystemEventHandler):
           def __init__(self):
               self._timer = None
               self._debounce_sec = 0.5

           def on_modified(self, event):
               if os.path.abspath(event.src_path) == os.path.abspath(config_path):
                   if self._timer:
                       self._timer.cancel()
                   self._timer = threading.Timer(self._debounce_sec, self._reload)
                   self._timer.start()

           def _reload(self):
               if config_mgr.load_json_file(config_path):
                   logging.info("Config reloaded from %s", config_path)
               else:
                   logging.warning("Config reload failed from %s", config_path)

       observer = Observer()
       handler = ConfigReloadHandler()
       observer.schedule(handler, os.path.dirname(os.path.abspath(config_path)), recursive=False)
       observer.daemon = True
       observer.start()
       logging.info("Config file watcher started for %s", config_path)
       return observer
   ```

5. In main(), after device connection succeeds and before the main stats loop:
   - Create config manager: `config_mgr = get_config_manager()` and `config_mgr.load_json_file(config_path)`
   - Start config watcher: `config_watcher = _start_config_watcher(config_path, config_mgr)`
   - Start vendor read thread:
     ```python
     vendor_thread = threading.Thread(
         target=_vendor_read_thread,
         args=(device, hid_lock, config_mgr),
         daemon=True
     )
     vendor_thread.start()
     ```

6. The hid_lock must be passed through to the notification callback too. Update the notification callback lambda to use hid_lock:
   ```python
   def _send_notif_locked(device, hid_lock, app, summary, body):
       with hid_lock:
           # ... existing send_notification_to_display logic but using the lock
   ```
   Actually, send_notification_to_display already does device.write -- just ensure the lock wrapping is at the call site in the notification thread's callback. The simplest approach: modify send_notification_to_display to accept an optional lock parameter, or just wrap the callback.

7. Important: the existing device.read() call for vendor HID does NOT exist in the current companion -- the companion only writes. The new read thread is the first consumer of device.read(). Make sure device.read(63, timeout_ms=100) is used with a short timeout so the thread yields the lock frequently for writes.
  </action>
  <verify>
   Run `cd /data/Elcrow-Display-hotkeys && python -c "
import companion.hotkey_companion as hc
# Check new functions exist
assert hasattr(hc, '_vendor_read_thread'), 'Missing _vendor_read_thread'
assert hasattr(hc, '_start_config_watcher'), 'Missing _start_config_watcher'
assert hc.MSG_BUTTON_PRESS == 0x0B, 'Wrong MSG_BUTTON_PRESS value'
print('OK')
"` -- prints OK.
  </verify>
  <done>Companion has a vendor HID read thread that receives MSG_BUTTON_PRESS and dispatches to action_executor. Config file watcher auto-reloads on changes. Thread-safe HID access via threading.Lock.</done>
</task>

</tasks>

<verification>
1. `python -c "from companion.action_executor import execute_action, _exec_launch_app, _exec_shell_cmd, _exec_open_url"` succeeds
2. `python -c "from companion.app_scanner import AppEntry; e = AppEntry('test','','','',[],'','',''); print(e.wm_class)"` prints empty string
3. `python -c "import companion.hotkey_companion as hc; print(hc.MSG_BUTTON_PRESS)"` prints 11
4. grep confirms _vendor_read_thread and _start_config_watcher exist in hotkey_companion.py
5. grep confirms hid_lock is used around device.write calls
</verification>

<success_criteria>
- action_executor.py handles all 5 action types (hotkey, media key, launch app, shell cmd, open URL)
- Shell commands with sudo are blocked
- Focus-or-launch uses wmctrl for window focus
- Keyboard shortcuts use ydotool (with xdotool fallback)
- Companion reads vendor HID input reports on a background thread
- Button presses dispatch to execute_action on separate daemon threads
- Config file changes trigger automatic reload with 500ms debounce
- All HID device access is protected by a threading.Lock
</success_criteria>

<output>
After completion, create `.planning/phases/10-companion-action-execution/10-02-SUMMARY.md`
</output>
