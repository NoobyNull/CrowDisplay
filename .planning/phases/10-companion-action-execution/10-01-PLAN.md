---
phase: 10-companion-action-execution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - shared/protocol.h
  - display/ui.cpp
  - display/espnow_link.cpp
  - display/espnow_link.h
  - bridge/main.cpp
  - bridge/usb_hid.cpp
  - bridge/usb_hid.h
  - companion/config_manager.py
autonomous: true

must_haves:
  truths:
    - "Display sends page index + widget index (not modifiers+keycode) when a button is pressed"
    - "Bridge receives MSG_BUTTON_PRESS, immediately ACKs display, relays to companion via vendor HID"
    - "Bridge no longer fires USB HID keystrokes or consumer control codes for button presses"
    - "Config manager has 5 action type constants: HOTKEY, MEDIA_KEY, LAUNCH_APP, SHELL_CMD, OPEN_URL"
  artifacts:
    - path: "shared/protocol.h"
      provides: "MSG_BUTTON_PRESS message type and ButtonPressMsg struct"
      contains: "MSG_BUTTON_PRESS"
    - path: "display/espnow_link.cpp"
      provides: "send_button_press_to_bridge function"
      contains: "send_button_press_to_bridge"
    - path: "bridge/usb_hid.cpp"
      provides: "send_vendor_report function for device-to-host INPUT reports"
      contains: "send_vendor_report"
    - path: "companion/config_manager.py"
      provides: "New action type constants ACTION_LAUNCH_APP, ACTION_SHELL_CMD, ACTION_OPEN_URL"
      contains: "ACTION_LAUNCH_APP"
  key_links:
    - from: "display/ui.cpp"
      to: "display/espnow_link.cpp"
      via: "btn_event_cb calls send_button_press_to_bridge"
      pattern: "send_button_press_to_bridge"
    - from: "bridge/main.cpp"
      to: "bridge/usb_hid.cpp"
      via: "MSG_BUTTON_PRESS case calls send_vendor_report"
      pattern: "send_vendor_report.*MSG_BUTTON_PRESS"
---

<objective>
Add MSG_BUTTON_PRESS protocol message and change the full button press pipeline from keystroke-based to identity-based: display sends page+widget index, bridge ACKs and relays to companion via vendor HID. Also extend config_manager with new action type constants for downstream plans.

Purpose: This is the foundation for companion action execution -- the display no longer tells the bridge WHAT to do (keystroke), it tells it WHICH button was pressed, and the companion decides the action.
Output: Updated firmware for display and bridge, new protocol message, extended config_manager constants.
</objective>

<execution_context>
@/home/matthew/.claude/get-shit-done/workflows/execute-plan.md
@/home/matthew/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-companion-action-execution/10-CONTEXT.md
@.planning/phases/10-companion-action-execution/10-RESEARCH.md
@shared/protocol.h
@display/ui.cpp
@display/espnow_link.cpp
@display/espnow_link.h
@bridge/main.cpp
@bridge/usb_hid.cpp
@bridge/usb_hid.h
@companion/config_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Protocol message + display firmware changes</name>
  <files>shared/protocol.h, display/espnow_link.cpp, display/espnow_link.h, display/ui.cpp</files>
  <action>
1. In shared/protocol.h:
   - Add MSG_BUTTON_PRESS = 0x0B to the MsgType enum (after MSG_CONFIG_DONE = 0x0A)
   - Add ButtonPressMsg struct (packed): uint8_t page_index, uint8_t widget_index

2. In display/espnow_link.h:
   - Add declaration: void send_button_press_to_bridge(uint8_t page_index, uint8_t widget_index);

3. In display/espnow_link.cpp:
   - Add send_button_press_to_bridge() function that creates a ButtonPressMsg and calls espnow_send(MSG_BUTTON_PRESS, ...)
   - Keep existing send_hotkey_to_bridge and send_media_key_to_bridge for now (they may be removed later but are harmless)

4. In display/ui.cpp:
   - The btn_event_cb currently gets a WidgetConfig* pointer. It needs to know the page index and widget index to send MSG_BUTTON_PRESS.
   - Change approach: create a small struct ButtonEventData { uint8_t page_idx; uint8_t widget_idx; } and store it alongside button creation. Allocate statically or from a small fixed pool (max 12 buttons per page x 16 pages = 192, but only one page is live at a time, so 32 max).
   - Use a static array of ButtonEventData (e.g., 32 entries) that gets reset on page rebuild. In render_hotkey_button(), assign the current page index and widget index to the next slot, pass its address as user_data to the event callback.
   - In btn_event_cb: extract page_idx and widget_idx from the ButtonEventData user_data, call send_button_press_to_bridge(page_idx, widget_idx) instead of send_hotkey_to_bridge or send_media_key_to_bridge.
   - The current_page variable already tracks which page is shown. The widget index can be tracked by a counter during render_hotkey_button calls for each page.

   Implementation detail for tracking indices:
   - Add a static array: static ButtonEventData btn_event_data[CONFIG_MAX_WIDGETS]; and static int btn_event_count = 0;
   - In the page creation code (create_pages or wherever render_hotkey_button is called in a loop over widgets), maintain a widget counter per page. Pass the page_index and widget_index into render_hotkey_button.
   - In render_hotkey_button, store {page_idx, widget_idx} in btn_event_data[btn_event_count++] and pass &btn_event_data[btn_event_count-1] as user_data.
   - Reset btn_event_count = 0 at the start of rebuild_ui / create_pages.
  </action>
  <verify>
   Run `cd /data/Elcrow-Display-hotkeys && pio run -e display` -- display firmware compiles without errors.
  </verify>
  <done>Display firmware compiles. btn_event_cb sends MSG_BUTTON_PRESS with page_index and widget_index instead of MSG_HOTKEY or MSG_MEDIA_KEY. ButtonPressMsg struct exists in protocol.h.</done>
</task>

<task type="auto">
  <name>Task 2: Bridge relay + vendor HID write + config_manager constants</name>
  <files>bridge/usb_hid.cpp, bridge/usb_hid.h, bridge/main.cpp, companion/config_manager.py</files>
  <action>
1. In bridge/usb_hid.h:
   - Add declaration: void send_vendor_report(uint8_t msg_type, const uint8_t *payload, uint8_t len);

2. In bridge/usb_hid.cpp:
   - Add send_vendor_report() function:
     ```cpp
     void send_vendor_report(uint8_t msg_type, const uint8_t *payload, uint8_t len) {
         uint8_t buf[63];
         memset(buf, 0, sizeof(buf));
         buf[0] = msg_type;
         if (len > 0 && payload) memcpy(&buf[1], payload, min((int)len, 62));
         Vendor.write(buf, 1 + len);
     }
     ```
   - The Vendor object is already static in usb_hid.cpp, so send_vendor_report has access.

3. In bridge/main.cpp, in the ESP-NOW poll switch statement (after MSG_PING case):
   - Add MSG_BUTTON_PRESS case:
     ```cpp
     case MSG_BUTTON_PRESS: {
         if (payload_len >= sizeof(ButtonPressMsg)) {
             // Immediately ACK display (fast visual feedback)
             HotkeyAckMsg ack = { 0 };
             espnow_send(MSG_HOTKEY_ACK, (uint8_t *)&ack, sizeof(ack));

             // Relay to companion via vendor HID INPUT report
             send_vendor_report(MSG_BUTTON_PRESS, payload, sizeof(ButtonPressMsg));
             Serial.printf("BTN: page=%d widget=%d -> companion\n",
                           payload[0], payload[1]);
         }
         break;
     }
     ```
   - Keep the existing MSG_HOTKEY and MSG_MEDIA_KEY cases -- they won't fire anymore (display no longer sends them for button presses) but removing them could break backward compat if old display firmware is used.

4. In companion/config_manager.py:
   - Add new action type constants after ACTION_MEDIA_KEY = 1:
     ```python
     ACTION_LAUNCH_APP = 2    # Launch/focus application
     ACTION_SHELL_CMD = 3     # Run shell command (fire and forget)
     ACTION_OPEN_URL = 4      # Open URL in default browser
     ```
   - Update the validation in validate() method: change the action_type check from
     `if at not in (ACTION_HOTKEY, ACTION_MEDIA_KEY):` to
     `if at not in (ACTION_HOTKEY, ACTION_MEDIA_KEY, ACTION_LAUNCH_APP, ACTION_SHELL_CMD, ACTION_OPEN_URL):`
   - Add new default fields to make_default_widget for WIDGET_HOTKEY_BUTTON:
     ```python
     "launch_command": "",
     "launch_wm_class": "",
     "launch_focus_or_launch": True,
     "shell_command": "",
     "url": "",
     ```
   - In _migrate_v1_page, also copy the new fields with defaults when migrating buttons.
  </action>
  <verify>
   Run `cd /data/Elcrow-Display-hotkeys && pio run -e bridge` -- bridge firmware compiles without errors.
   Run `cd /data/Elcrow-Display-hotkeys && python -c "from companion.config_manager import ACTION_LAUNCH_APP, ACTION_SHELL_CMD, ACTION_OPEN_URL; print('OK')"` -- prints OK.
  </verify>
  <done>Bridge handles MSG_BUTTON_PRESS by ACKing display and relaying to companion via Vendor.write(). Config manager has 5 action type constants and new widget fields for launch_command, shell_command, url, launch_wm_class, launch_focus_or_launch.</done>
</task>

</tasks>

<verification>
1. `pio run -e display` compiles successfully
2. `pio run -e bridge` compiles successfully
3. `python -c "from companion.config_manager import ACTION_LAUNCH_APP; print(ACTION_LAUNCH_APP)"` prints 2
4. grep confirms MSG_BUTTON_PRESS exists in protocol.h
5. grep confirms send_button_press_to_bridge exists in espnow_link.cpp
6. grep confirms send_vendor_report exists in usb_hid.cpp
</verification>

<success_criteria>
- Display firmware sends MSG_BUTTON_PRESS(page_index, widget_index) on button tap instead of MSG_HOTKEY or MSG_MEDIA_KEY
- Bridge firmware receives MSG_BUTTON_PRESS, immediately sends MSG_HOTKEY_ACK to display, and relays to companion via Vendor.write()
- Config manager has ACTION_LAUNCH_APP=2, ACTION_SHELL_CMD=3, ACTION_OPEN_URL=4 constants
- Config manager validation accepts the new action types
- Both firmware targets compile clean
</success_criteria>

<output>
After completion, create `.planning/phases/10-companion-action-execution/10-01-SUMMARY.md`
</output>
